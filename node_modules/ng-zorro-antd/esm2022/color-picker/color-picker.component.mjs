import { __decorate } from "tslib";
/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, Component, EventEmitter, forwardRef, Input, Output } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { defaultColor, generateColor } from 'ng-antd-color-picker';
import { InputBoolean, isNonEmptyString, isTemplateRef } from 'ng-zorro-antd/core/util';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "@angular/common";
import * as i3 from "ng-antd-color-picker";
import * as i4 from "ng-zorro-antd/popover";
import * as i5 from "./color-block.component";
import * as i6 from "./color-format.component";
export class NzColorPickerComponent {
    constructor(formBuilder, cdr) {
        this.formBuilder = formBuilder;
        this.cdr = cdr;
        this.nzFormat = null;
        this.nzValue = '';
        this.nzSize = 'default';
        this.nzDefaultValue = '';
        this.nzTrigger = 'click';
        this.nzTitle = '';
        this.nzFlipFlop = null;
        this.nzShowText = false;
        this.nzOpen = false;
        this.nzAllowClear = false;
        this.nzDisabled = false;
        this.nzDisabledAlpha = false;
        this.nzOnChange = new EventEmitter();
        this.nzOnFormatChange = new EventEmitter();
        this.nzOnClear = new EventEmitter();
        this.nzOnOpenChange = new EventEmitter();
        this.isTemplateRef = isTemplateRef;
        this.isNonEmptyString = isNonEmptyString;
        this.destroy$ = new Subject();
        this.isNzDisableFirstChange = true;
        this.blockColor = '';
        this.clearColor = false;
        this.showText = defaultColor.toHexString();
        this.formControl = this.formBuilder.control('');
        this.onChange = () => { };
    }
    writeValue(value) {
        this.nzValue = value;
        this.getBlockColor();
        this.formControl.patchValue(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched() { }
    setDisabledState(isDisabled) {
        this.nzDisabled = (this.isNzDisableFirstChange && this.nzDisabled) || isDisabled;
        this.isNzDisableFirstChange = false;
        this.cdr.markForCheck();
    }
    ngOnInit() {
        this.getBlockColor();
        this.formControl.valueChanges.pipe(takeUntil(this.destroy$)).subscribe(value => {
            if (!!value) {
                let color = value;
                if (this.nzFormat === 'hex') {
                    color =
                        generateColor(value).getAlpha() < 1
                            ? generateColor(value).toHex8String()
                            : generateColor(value).toHexString();
                }
                else if (this.nzFormat === 'hsb') {
                    color = generateColor(value).toHsbString();
                }
                else if (this.nzFormat === 'rgb') {
                    color = generateColor(value).toRgbString();
                }
                this.showText = color;
                this.onChange(color);
                this.cdr.markForCheck();
            }
        });
    }
    ngOnChanges(changes) {
        const { nzValue, nzDefaultValue } = changes;
        if (nzValue || nzDefaultValue) {
            this.getBlockColor();
        }
    }
    clearColorHandle() {
        this.clearColor = true;
        this.nzOnClear.emit(true);
        this.cdr.markForCheck();
    }
    getBlockColor() {
        if (!!this.nzValue) {
            this.blockColor = generateColor(this.nzValue).toRgbString();
        }
        else if (!!this.nzDefaultValue) {
            this.blockColor = generateColor(this.nzDefaultValue).toRgbString();
        }
        else {
            this.blockColor = defaultColor.toHexString();
        }
    }
    colorChange(value) {
        this.blockColor = value.color.getAlpha() < 1 ? value.color.toHex8String() : value.color.toHexString();
        this.clearColor = false;
        this.cdr.markForCheck();
    }
    formatChange(value) {
        this.nzValue = value.color;
        this.clearColor = false;
        this.getBlockColor();
        this.nzOnChange.emit({ color: generateColor(value.color), format: value.format });
        this.formControl.patchValue(value.color);
        this.cdr.markForCheck();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.7", ngImport: i0, type: NzColorPickerComponent, deps: [{ token: i1.FormBuilder }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.7", type: NzColorPickerComponent, selector: "nz-color-picker", inputs: { nzFormat: "nzFormat", nzValue: "nzValue", nzSize: "nzSize", nzDefaultValue: "nzDefaultValue", nzTrigger: "nzTrigger", nzTitle: "nzTitle", nzFlipFlop: "nzFlipFlop", nzShowText: "nzShowText", nzOpen: "nzOpen", nzAllowClear: "nzAllowClear", nzDisabled: "nzDisabled", nzDisabledAlpha: "nzDisabledAlpha" }, outputs: { nzOnChange: "nzOnChange", nzOnFormatChange: "nzOnFormatChange", nzOnClear: "nzOnClear", nzOnOpenChange: "nzOnOpenChange" }, host: { properties: { "class.ant-color-picker-disabled": "nzDisabled" }, classAttribute: "ant-color-picker-inline" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NzColorPickerComponent),
                multi: true
            }
        ], exportAs: ["NzColorPicker"], usesOnChanges: true, ngImport: i0, template: `
    <div
      [class.ant-color-picker-trigger]="!nzFlipFlop"
      [class.ant-color-picker-sm]="nzSize === 'small'"
      [class.ant-color-picker-lg]="nzSize === 'large'"
      nz-popover
      [nzPopoverContent]="colorPicker"
      [nzPopoverTrigger]="!nzDisabled ? nzTrigger : null"
      [nzPopoverVisible]="nzOpen"
      (nzPopoverVisibleChange)="nzOnOpenChange.emit($event)"
    >
      <ng-container *ngIf="!nzFlipFlop">
        <nz-color-block [nzColor]="blockColor" [nzSize]="nzSize"></nz-color-block>
      </ng-container>
      <ng-container *ngIf="nzFlipFlop">
        <ng-template [ngTemplateOutlet]="nzFlipFlop"></ng-template>
      </ng-container>
      <div class="ant-color-picker-trigger-text" *ngIf="nzShowText && !!showText && !nzFlipFlop">
        {{ showText }}
      </div>
    </div>
    <ng-template #colorPicker>
      <ng-antd-color-picker
        [value]="nzValue"
        [defaultValue]="nzDefaultValue"
        [disabled]="nzDisabled"
        [panelRenderHeader]="nzPanelRenderHeader"
        [panelRenderFooter]="nzPanelRenderFooter"
        [disabledAlpha]="nzDisabledAlpha"
        (nzOnChange)="colorChange($event)"
      ></ng-antd-color-picker>
    </ng-template>
    <ng-template #nzPanelRenderHeader>
      <div class="ant-color-picker-title" *ngIf="nzAllowClear || nzTitle">
        <div class="ant-color-picker-title-content">
          <ng-container [ngSwitch]="true">
            <ng-container *ngSwitchCase="isTemplateRef(nzTitle)">
              <ng-container *ngTemplateOutlet="$any(nzTitle)"></ng-container>
            </ng-container>
            <ng-container *ngSwitchCase="isNonEmptyString(nzTitle)">
              <span [innerHTML]="nzTitle"></span>
            </ng-container>
          </ng-container>
        </div>
        <div class="ant-color-picker-clear" *ngIf="nzAllowClear" (click)="clearColorHandle()"></div>
      </div>
    </ng-template>
    <ng-template #nzPanelRenderFooter>
      <nz-color-format
        [colorValue]="blockColor"
        [clearColor]="clearColor"
        [format]="nzFormat"
        [nzDisabledAlpha]="nzDisabledAlpha"
        (formatChange)="formatChange($event)"
        (nzOnFormatChange)="nzOnFormatChange.emit($event)"
      ></nz-color-format>
    </ng-template>
  `, isInline: true, dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i2.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i2.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "component", type: i3.NgAntdColorPickerComponent, selector: "ng-antd-color-picker", inputs: ["value", "defaultValue", "panelRenderHeader", "panelRenderFooter", "disabledAlpha", "disabled"], outputs: ["nzOnChange", "nzOnChangeComplete"] }, { kind: "directive", type: i4.NzPopoverDirective, selector: "[nz-popover]", inputs: ["nzPopoverArrowPointAtCenter", "nzPopoverTitle", "nzPopoverContent", "nz-popover", "nzPopoverTrigger", "nzPopoverPlacement", "nzPopoverOrigin", "nzPopoverVisible", "nzPopoverMouseEnterDelay", "nzPopoverMouseLeaveDelay", "nzPopoverOverlayClassName", "nzPopoverOverlayStyle", "nzPopoverBackdrop"], outputs: ["nzPopoverVisibleChange"], exportAs: ["nzPopover"] }, { kind: "component", type: i5.NzColorBlockComponent, selector: "nz-color-block", inputs: ["nzColor", "nzSize"], outputs: ["nzOnClick"], exportAs: ["NzColorBlock"] }, { kind: "component", type: i6.NzColorFormatComponent, selector: "nz-color-format", inputs: ["format", "colorValue", "clearColor", "nzDisabledAlpha"], outputs: ["formatChange", "nzOnFormatChange"], exportAs: ["NzColorFormat"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
__decorate([
    InputBoolean()
], NzColorPickerComponent.prototype, "nzShowText", void 0);
__decorate([
    InputBoolean()
], NzColorPickerComponent.prototype, "nzOpen", void 0);
__decorate([
    InputBoolean()
], NzColorPickerComponent.prototype, "nzAllowClear", void 0);
__decorate([
    InputBoolean()
], NzColorPickerComponent.prototype, "nzDisabled", void 0);
__decorate([
    InputBoolean()
], NzColorPickerComponent.prototype, "nzDisabledAlpha", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.7", ngImport: i0, type: NzColorPickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-color-picker',
                    exportAs: 'NzColorPicker',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
    <div
      [class.ant-color-picker-trigger]="!nzFlipFlop"
      [class.ant-color-picker-sm]="nzSize === 'small'"
      [class.ant-color-picker-lg]="nzSize === 'large'"
      nz-popover
      [nzPopoverContent]="colorPicker"
      [nzPopoverTrigger]="!nzDisabled ? nzTrigger : null"
      [nzPopoverVisible]="nzOpen"
      (nzPopoverVisibleChange)="nzOnOpenChange.emit($event)"
    >
      <ng-container *ngIf="!nzFlipFlop">
        <nz-color-block [nzColor]="blockColor" [nzSize]="nzSize"></nz-color-block>
      </ng-container>
      <ng-container *ngIf="nzFlipFlop">
        <ng-template [ngTemplateOutlet]="nzFlipFlop"></ng-template>
      </ng-container>
      <div class="ant-color-picker-trigger-text" *ngIf="nzShowText && !!showText && !nzFlipFlop">
        {{ showText }}
      </div>
    </div>
    <ng-template #colorPicker>
      <ng-antd-color-picker
        [value]="nzValue"
        [defaultValue]="nzDefaultValue"
        [disabled]="nzDisabled"
        [panelRenderHeader]="nzPanelRenderHeader"
        [panelRenderFooter]="nzPanelRenderFooter"
        [disabledAlpha]="nzDisabledAlpha"
        (nzOnChange)="colorChange($event)"
      ></ng-antd-color-picker>
    </ng-template>
    <ng-template #nzPanelRenderHeader>
      <div class="ant-color-picker-title" *ngIf="nzAllowClear || nzTitle">
        <div class="ant-color-picker-title-content">
          <ng-container [ngSwitch]="true">
            <ng-container *ngSwitchCase="isTemplateRef(nzTitle)">
              <ng-container *ngTemplateOutlet="$any(nzTitle)"></ng-container>
            </ng-container>
            <ng-container *ngSwitchCase="isNonEmptyString(nzTitle)">
              <span [innerHTML]="nzTitle"></span>
            </ng-container>
          </ng-container>
        </div>
        <div class="ant-color-picker-clear" *ngIf="nzAllowClear" (click)="clearColorHandle()"></div>
      </div>
    </ng-template>
    <ng-template #nzPanelRenderFooter>
      <nz-color-format
        [colorValue]="blockColor"
        [clearColor]="clearColor"
        [format]="nzFormat"
        [nzDisabledAlpha]="nzDisabledAlpha"
        (formatChange)="formatChange($event)"
        (nzOnFormatChange)="nzOnFormatChange.emit($event)"
      ></nz-color-format>
    </ng-template>
  `,
                    host: {
                        class: 'ant-color-picker-inline',
                        '[class.ant-color-picker-disabled]': `nzDisabled`
                    },
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => NzColorPickerComponent),
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: () => [{ type: i1.FormBuilder }, { type: i0.ChangeDetectorRef }], propDecorators: { nzFormat: [{
                type: Input
            }], nzValue: [{
                type: Input
            }], nzSize: [{
                type: Input
            }], nzDefaultValue: [{
                type: Input
            }], nzTrigger: [{
                type: Input
            }], nzTitle: [{
                type: Input
            }], nzFlipFlop: [{
                type: Input
            }], nzShowText: [{
                type: Input
            }], nzOpen: [{
                type: Input
            }], nzAllowClear: [{
                type: Input
            }], nzDisabled: [{
                type: Input
            }], nzDisabledAlpha: [{
                type: Input
            }], nzOnChange: [{
                type: Output
            }], nzOnFormatChange: [{
                type: Output
            }], nzOnClear: [{
                type: Output
            }], nzOnOpenChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3ItcGlja2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL2NvbG9yLXBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFDTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULFlBQVksRUFDWixVQUFVLEVBQ1YsS0FBSyxFQUlMLE1BQU0sRUFHUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXFDLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUduRSxPQUFPLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxNQUFNLHlCQUF5QixDQUFDOzs7Ozs7OztBQThFeEYsTUFBTSxPQUFPLHNCQUFzQjtJQWdDakMsWUFDVSxXQUF3QixFQUN4QixHQUFzQjtRQUR0QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4QixRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQTNCdkIsYUFBUSxHQUFtQyxJQUFJLENBQUM7UUFDaEQsWUFBTyxHQUFxQixFQUFFLENBQUM7UUFDL0IsV0FBTSxHQUFrQixTQUFTLENBQUM7UUFDbEMsbUJBQWMsR0FBcUIsRUFBRSxDQUFDO1FBQ3RDLGNBQVMsR0FBNkIsT0FBTyxDQUFDO1FBQzlDLFlBQU8sR0FBK0IsRUFBRSxDQUFDO1FBQ3pDLGVBQVUsR0FBNkIsSUFBSSxDQUFDO1FBQzVCLGVBQVUsR0FBWSxLQUFLLENBQUM7UUFDNUIsV0FBTSxHQUFZLEtBQUssQ0FBQztRQUN4QixpQkFBWSxHQUFZLEtBQUssQ0FBQztRQUM5QixlQUFVLEdBQVksS0FBSyxDQUFDO1FBQzVCLG9CQUFlLEdBQVksS0FBSyxDQUFDO1FBQ3ZDLGVBQVUsR0FBRyxJQUFJLFlBQVksRUFBc0MsQ0FBQztRQUNwRSxxQkFBZ0IsR0FBRyxJQUFJLFlBQVksRUFBMkIsQ0FBQztRQUMvRCxjQUFTLEdBQUcsSUFBSSxZQUFZLEVBQVcsQ0FBQztRQUN4QyxtQkFBYyxHQUFHLElBQUksWUFBWSxFQUFXLENBQUM7UUFFN0Msa0JBQWEsR0FBRyxhQUFhLENBQUM7UUFDOUIscUJBQWdCLEdBQUcsZ0JBQWdCLENBQUM7UUFDL0MsYUFBUSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFDL0IsMkJBQXNCLEdBQVksSUFBSSxDQUFDO1FBQy9DLGVBQVUsR0FBVyxFQUFFLENBQUM7UUFDeEIsZUFBVSxHQUFZLEtBQUssQ0FBQztRQUM1QixhQUFRLEdBQVcsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBTzlDLGdCQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFM0MsYUFBUSxHQUE0QixHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUM7SUFKMUMsQ0FBQztJQU1KLFVBQVUsQ0FBQyxLQUFhO1FBQ3RCLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsRUFBYTtRQUM1QixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRUQsaUJBQWlCLEtBQVUsQ0FBQztJQUU1QixnQkFBZ0IsQ0FBQyxVQUFtQjtRQUNsQyxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsSUFBSSxDQUFDLHNCQUFzQixJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxVQUFVLENBQUM7UUFDakYsSUFBSSxDQUFDLHNCQUFzQixHQUFHLEtBQUssQ0FBQztRQUNwQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRCxRQUFRO1FBQ04sSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzdFLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRTtnQkFDWCxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7Z0JBQ2xCLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxLQUFLLEVBQUU7b0JBQzNCLEtBQUs7d0JBQ0gsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUM7NEJBQ2pDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWSxFQUFFOzRCQUNyQyxDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO2lCQUMxQztxQkFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssS0FBSyxFQUFFO29CQUNsQyxLQUFLLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO2lCQUM1QztxQkFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssS0FBSyxFQUFFO29CQUNsQyxLQUFLLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO2lCQUM1QztnQkFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztnQkFDdEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDckIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUN6QjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUNoQyxNQUFNLEVBQUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUM1QyxJQUFJLE9BQU8sSUFBSSxjQUFjLEVBQUU7WUFDN0IsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQ3RCO0lBQ0gsQ0FBQztJQUVELGdCQUFnQjtRQUNkLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVELGFBQWE7UUFDWCxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUM3RDthQUFNLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDaEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxhQUFhLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BFO2FBQU07WUFDTCxJQUFJLENBQUMsVUFBVSxHQUFHLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUM5QztJQUNILENBQUM7SUFFRCxXQUFXLENBQUMsS0FBeUI7UUFDbkMsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN0RyxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUN4QixJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRCxZQUFZLENBQUMsS0FBeUQ7UUFDcEUsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO1FBQzNCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxhQUFhLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUNsRixJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMzQixDQUFDOzhHQTFIVSxzQkFBc0I7a0dBQXRCLHNCQUFzQiwrbEJBUnRCO1lBQ1Q7Z0JBQ0UsT0FBTyxFQUFFLGlCQUFpQjtnQkFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQztnQkFDckQsS0FBSyxFQUFFLElBQUk7YUFDWjtTQUNGLDRFQXBFUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeURUOztBQTJCd0I7SUFBZixZQUFZLEVBQUU7MERBQTZCO0FBQzVCO0lBQWYsWUFBWSxFQUFFO3NEQUF5QjtBQUN4QjtJQUFmLFlBQVksRUFBRTs0REFBK0I7QUFDOUI7SUFBZixZQUFZLEVBQUU7MERBQTZCO0FBQzVCO0lBQWYsWUFBWSxFQUFFOytEQUFrQzsyRkFsQi9DLHNCQUFzQjtrQkExRWxDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGlCQUFpQjtvQkFDM0IsUUFBUSxFQUFFLGVBQWU7b0JBQ3pCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlEVDtvQkFDRCxJQUFJLEVBQUU7d0JBQ0osS0FBSyxFQUFFLHlCQUF5Qjt3QkFDaEMsbUNBQW1DLEVBQUUsWUFBWTtxQkFDbEQ7b0JBQ0QsU0FBUyxFQUFFO3dCQUNUOzRCQUNFLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLHVCQUF1QixDQUFDOzRCQUNyRCxLQUFLLEVBQUUsSUFBSTt5QkFDWjtxQkFDRjtpQkFDRjtnSEFRVSxRQUFRO3NCQUFoQixLQUFLO2dCQUNHLE9BQU87c0JBQWYsS0FBSztnQkFDRyxNQUFNO3NCQUFkLEtBQUs7Z0JBQ0csY0FBYztzQkFBdEIsS0FBSztnQkFDRyxTQUFTO3NCQUFqQixLQUFLO2dCQUNHLE9BQU87c0JBQWYsS0FBSztnQkFDRyxVQUFVO3NCQUFsQixLQUFLO2dCQUNtQixVQUFVO3NCQUFsQyxLQUFLO2dCQUNtQixNQUFNO3NCQUE5QixLQUFLO2dCQUNtQixZQUFZO3NCQUFwQyxLQUFLO2dCQUNtQixVQUFVO3NCQUFsQyxLQUFLO2dCQUNtQixlQUFlO3NCQUF2QyxLQUFLO2dCQUNhLFVBQVU7c0JBQTVCLE1BQU07Z0JBQ1ksZ0JBQWdCO3NCQUFsQyxNQUFNO2dCQUNZLFNBQVM7c0JBQTNCLE1BQU07Z0JBQ1ksY0FBYztzQkFBaEMsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL05HLVpPUlJPL25nLXpvcnJvLWFudGQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIGZvcndhcmRSZWYsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFRlbXBsYXRlUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEZvcm1CdWlsZGVyLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgZGVmYXVsdENvbG9yLCBnZW5lcmF0ZUNvbG9yIH0gZnJvbSAnbmctYW50ZC1jb2xvci1waWNrZXInO1xuXG5pbXBvcnQgeyBCb29sZWFuSW5wdXQsIE56U2FmZUFueSwgTnpTaXplTERTVHlwZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS90eXBlcyc7XG5pbXBvcnQgeyBJbnB1dEJvb2xlYW4sIGlzTm9uRW1wdHlTdHJpbmcsIGlzVGVtcGxhdGVSZWYgfSBmcm9tICduZy16b3Jyby1hbnRkL2NvcmUvdXRpbCc7XG5cbmltcG9ydCB7IE56Q29sb3IsIE56Q29sb3JQaWNrZXJUcmlnZ2VyVHlwZSwgTnpDb2xvclBpY2tlckZvcm1hdFR5cGUgfSBmcm9tICcuL3R5cGluZ3MnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduei1jb2xvci1waWNrZXInLFxuICBleHBvcnRBczogJ056Q29sb3JQaWNrZXInLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2XG4gICAgICBbY2xhc3MuYW50LWNvbG9yLXBpY2tlci10cmlnZ2VyXT1cIiFuekZsaXBGbG9wXCJcbiAgICAgIFtjbGFzcy5hbnQtY29sb3ItcGlja2VyLXNtXT1cIm56U2l6ZSA9PT0gJ3NtYWxsJ1wiXG4gICAgICBbY2xhc3MuYW50LWNvbG9yLXBpY2tlci1sZ109XCJuelNpemUgPT09ICdsYXJnZSdcIlxuICAgICAgbnotcG9wb3ZlclxuICAgICAgW256UG9wb3ZlckNvbnRlbnRdPVwiY29sb3JQaWNrZXJcIlxuICAgICAgW256UG9wb3ZlclRyaWdnZXJdPVwiIW56RGlzYWJsZWQgPyBuelRyaWdnZXIgOiBudWxsXCJcbiAgICAgIFtuelBvcG92ZXJWaXNpYmxlXT1cIm56T3BlblwiXG4gICAgICAobnpQb3BvdmVyVmlzaWJsZUNoYW5nZSk9XCJuek9uT3BlbkNoYW5nZS5lbWl0KCRldmVudClcIlxuICAgID5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhbnpGbGlwRmxvcFwiPlxuICAgICAgICA8bnotY29sb3ItYmxvY2sgW256Q29sb3JdPVwiYmxvY2tDb2xvclwiIFtuelNpemVdPVwibnpTaXplXCI+PC9uei1jb2xvci1ibG9jaz5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIm56RmxpcEZsb3BcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm56RmxpcEZsb3BcIj48L25nLXRlbXBsYXRlPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICA8ZGl2IGNsYXNzPVwiYW50LWNvbG9yLXBpY2tlci10cmlnZ2VyLXRleHRcIiAqbmdJZj1cIm56U2hvd1RleHQgJiYgISFzaG93VGV4dCAmJiAhbnpGbGlwRmxvcFwiPlxuICAgICAgICB7eyBzaG93VGV4dCB9fVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPG5nLXRlbXBsYXRlICNjb2xvclBpY2tlcj5cbiAgICAgIDxuZy1hbnRkLWNvbG9yLXBpY2tlclxuICAgICAgICBbdmFsdWVdPVwibnpWYWx1ZVwiXG4gICAgICAgIFtkZWZhdWx0VmFsdWVdPVwibnpEZWZhdWx0VmFsdWVcIlxuICAgICAgICBbZGlzYWJsZWRdPVwibnpEaXNhYmxlZFwiXG4gICAgICAgIFtwYW5lbFJlbmRlckhlYWRlcl09XCJuelBhbmVsUmVuZGVySGVhZGVyXCJcbiAgICAgICAgW3BhbmVsUmVuZGVyRm9vdGVyXT1cIm56UGFuZWxSZW5kZXJGb290ZXJcIlxuICAgICAgICBbZGlzYWJsZWRBbHBoYV09XCJuekRpc2FibGVkQWxwaGFcIlxuICAgICAgICAobnpPbkNoYW5nZSk9XCJjb2xvckNoYW5nZSgkZXZlbnQpXCJcbiAgICAgID48L25nLWFudGQtY29sb3ItcGlja2VyPlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPG5nLXRlbXBsYXRlICNuelBhbmVsUmVuZGVySGVhZGVyPlxuICAgICAgPGRpdiBjbGFzcz1cImFudC1jb2xvci1waWNrZXItdGl0bGVcIiAqbmdJZj1cIm56QWxsb3dDbGVhciB8fCBuelRpdGxlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbnQtY29sb3ItcGlja2VyLXRpdGxlLWNvbnRlbnRcIj5cbiAgICAgICAgICA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJ0cnVlXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1N3aXRjaENhc2U9XCJpc1RlbXBsYXRlUmVmKG56VGl0bGUpXCI+XG4gICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCIkYW55KG56VGl0bGUpXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cImlzTm9uRW1wdHlTdHJpbmcobnpUaXRsZSlcIj5cbiAgICAgICAgICAgICAgPHNwYW4gW2lubmVySFRNTF09XCJuelRpdGxlXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYW50LWNvbG9yLXBpY2tlci1jbGVhclwiICpuZ0lmPVwibnpBbGxvd0NsZWFyXCIgKGNsaWNrKT1cImNsZWFyQ29sb3JIYW5kbGUoKVwiPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8bmctdGVtcGxhdGUgI256UGFuZWxSZW5kZXJGb290ZXI+XG4gICAgICA8bnotY29sb3ItZm9ybWF0XG4gICAgICAgIFtjb2xvclZhbHVlXT1cImJsb2NrQ29sb3JcIlxuICAgICAgICBbY2xlYXJDb2xvcl09XCJjbGVhckNvbG9yXCJcbiAgICAgICAgW2Zvcm1hdF09XCJuekZvcm1hdFwiXG4gICAgICAgIFtuekRpc2FibGVkQWxwaGFdPVwibnpEaXNhYmxlZEFscGhhXCJcbiAgICAgICAgKGZvcm1hdENoYW5nZSk9XCJmb3JtYXRDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgIChuek9uRm9ybWF0Q2hhbmdlKT1cIm56T25Gb3JtYXRDaGFuZ2UuZW1pdCgkZXZlbnQpXCJcbiAgICAgID48L256LWNvbG9yLWZvcm1hdD5cbiAgICA8L25nLXRlbXBsYXRlPlxuICBgLFxuICBob3N0OiB7XG4gICAgY2xhc3M6ICdhbnQtY29sb3ItcGlja2VyLWlubGluZScsXG4gICAgJ1tjbGFzcy5hbnQtY29sb3ItcGlja2VyLWRpc2FibGVkXSc6IGBuekRpc2FibGVkYFxuICB9LFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE56Q29sb3JQaWNrZXJDb21wb25lbnQpLFxuICAgICAgbXVsdGk6IHRydWVcbiAgICB9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgTnpDb2xvclBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25EZXN0cm95IHtcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX256U2hvd1RleHQ6IEJvb2xlYW5JbnB1dDtcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX256T3BlbjogQm9vbGVhbklucHV0O1xuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbnpBbGxvd0NsZWFyOiBCb29sZWFuSW5wdXQ7XG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9uekRpc2FibGVkOiBCb29sZWFuSW5wdXQ7XG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9uekRpc2FibGVkQWxwaGE6IEJvb2xlYW5JbnB1dDtcblxuICBASW5wdXQoKSBuekZvcm1hdDogTnpDb2xvclBpY2tlckZvcm1hdFR5cGUgfCBudWxsID0gbnVsbDtcbiAgQElucHV0KCkgbnpWYWx1ZTogc3RyaW5nIHwgTnpDb2xvciA9ICcnO1xuICBASW5wdXQoKSBuelNpemU6IE56U2l6ZUxEU1R5cGUgPSAnZGVmYXVsdCc7XG4gIEBJbnB1dCgpIG56RGVmYXVsdFZhbHVlOiBzdHJpbmcgfCBOekNvbG9yID0gJyc7XG4gIEBJbnB1dCgpIG56VHJpZ2dlcjogTnpDb2xvclBpY2tlclRyaWdnZXJUeXBlID0gJ2NsaWNrJztcbiAgQElucHV0KCkgbnpUaXRsZTogVGVtcGxhdGVSZWY8dm9pZD4gfCBzdHJpbmcgPSAnJztcbiAgQElucHV0KCkgbnpGbGlwRmxvcDogVGVtcGxhdGVSZWY8dm9pZD4gfCBudWxsID0gbnVsbDtcbiAgQElucHV0KCkgQElucHV0Qm9vbGVhbigpIG56U2hvd1RleHQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCkgQElucHV0Qm9vbGVhbigpIG56T3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoKSBASW5wdXRCb29sZWFuKCkgbnpBbGxvd0NsZWFyOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIEBJbnB1dEJvb2xlYW4oKSBuekRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIEBJbnB1dEJvb2xlYW4oKSBuekRpc2FibGVkQWxwaGE6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IG56T25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHsgY29sb3I6IE56Q29sb3I7IGZvcm1hdDogc3RyaW5nIH0+KCk7XG4gIEBPdXRwdXQoKSByZWFkb25seSBuek9uRm9ybWF0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxOekNvbG9yUGlja2VyRm9ybWF0VHlwZT4oKTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IG56T25DbGVhciA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IG56T25PcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIHByb3RlY3RlZCByZWFkb25seSBpc1RlbXBsYXRlUmVmID0gaXNUZW1wbGF0ZVJlZjtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGlzTm9uRW1wdHlTdHJpbmcgPSBpc05vbkVtcHR5U3RyaW5nO1xuICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgcHJpdmF0ZSBpc056RGlzYWJsZUZpcnN0Q2hhbmdlOiBib29sZWFuID0gdHJ1ZTtcbiAgYmxvY2tDb2xvcjogc3RyaW5nID0gJyc7XG4gIGNsZWFyQ29sb3I6IGJvb2xlYW4gPSBmYWxzZTtcbiAgc2hvd1RleHQ6IHN0cmluZyA9IGRlZmF1bHRDb2xvci50b0hleFN0cmluZygpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZm9ybUJ1aWxkZXI6IEZvcm1CdWlsZGVyLFxuICAgIHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHt9XG5cbiAgZm9ybUNvbnRyb2wgPSB0aGlzLmZvcm1CdWlsZGVyLmNvbnRyb2woJycpO1xuXG4gIG9uQ2hhbmdlOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4gIHdyaXRlVmFsdWUodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMubnpWYWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuZ2V0QmxvY2tDb2xvcigpO1xuICAgIHRoaXMuZm9ybUNvbnRyb2wucGF0Y2hWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBOelNhZmVBbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZCgpOiB2b2lkIHt9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5uekRpc2FibGVkID0gKHRoaXMuaXNOekRpc2FibGVGaXJzdENoYW5nZSAmJiB0aGlzLm56RGlzYWJsZWQpIHx8IGlzRGlzYWJsZWQ7XG4gICAgdGhpcy5pc056RGlzYWJsZUZpcnN0Q2hhbmdlID0gZmFsc2U7XG4gICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmdldEJsb2NrQ29sb3IoKTtcbiAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgIGlmICghIXZhbHVlKSB7XG4gICAgICAgIGxldCBjb2xvciA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5uekZvcm1hdCA9PT0gJ2hleCcpIHtcbiAgICAgICAgICBjb2xvciA9XG4gICAgICAgICAgICBnZW5lcmF0ZUNvbG9yKHZhbHVlKS5nZXRBbHBoYSgpIDwgMVxuICAgICAgICAgICAgICA/IGdlbmVyYXRlQ29sb3IodmFsdWUpLnRvSGV4OFN0cmluZygpXG4gICAgICAgICAgICAgIDogZ2VuZXJhdGVDb2xvcih2YWx1ZSkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm56Rm9ybWF0ID09PSAnaHNiJykge1xuICAgICAgICAgIGNvbG9yID0gZ2VuZXJhdGVDb2xvcih2YWx1ZSkudG9Ic2JTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm56Rm9ybWF0ID09PSAncmdiJykge1xuICAgICAgICAgIGNvbG9yID0gZ2VuZXJhdGVDb2xvcih2YWx1ZSkudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3dUZXh0ID0gY29sb3I7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoY29sb3IpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBjb25zdCB7IG56VmFsdWUsIG56RGVmYXVsdFZhbHVlIH0gPSBjaGFuZ2VzO1xuICAgIGlmIChuelZhbHVlIHx8IG56RGVmYXVsdFZhbHVlKSB7XG4gICAgICB0aGlzLmdldEJsb2NrQ29sb3IoKTtcbiAgICB9XG4gIH1cblxuICBjbGVhckNvbG9ySGFuZGxlKCk6IHZvaWQge1xuICAgIHRoaXMuY2xlYXJDb2xvciA9IHRydWU7XG4gICAgdGhpcy5uek9uQ2xlYXIuZW1pdCh0cnVlKTtcbiAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIGdldEJsb2NrQ29sb3IoKTogdm9pZCB7XG4gICAgaWYgKCEhdGhpcy5uelZhbHVlKSB7XG4gICAgICB0aGlzLmJsb2NrQ29sb3IgPSBnZW5lcmF0ZUNvbG9yKHRoaXMubnpWYWx1ZSkudG9SZ2JTdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKCEhdGhpcy5uekRlZmF1bHRWYWx1ZSkge1xuICAgICAgdGhpcy5ibG9ja0NvbG9yID0gZ2VuZXJhdGVDb2xvcih0aGlzLm56RGVmYXVsdFZhbHVlKS50b1JnYlN0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJsb2NrQ29sb3IgPSBkZWZhdWx0Q29sb3IudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gIH1cblxuICBjb2xvckNoYW5nZSh2YWx1ZTogeyBjb2xvcjogTnpDb2xvciB9KTogdm9pZCB7XG4gICAgdGhpcy5ibG9ja0NvbG9yID0gdmFsdWUuY29sb3IuZ2V0QWxwaGEoKSA8IDEgPyB2YWx1ZS5jb2xvci50b0hleDhTdHJpbmcoKSA6IHZhbHVlLmNvbG9yLnRvSGV4U3RyaW5nKCk7XG4gICAgdGhpcy5jbGVhckNvbG9yID0gZmFsc2U7XG4gICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBmb3JtYXRDaGFuZ2UodmFsdWU6IHsgY29sb3I6IHN0cmluZzsgZm9ybWF0OiBOekNvbG9yUGlja2VyRm9ybWF0VHlwZSB9KTogdm9pZCB7XG4gICAgdGhpcy5uelZhbHVlID0gdmFsdWUuY29sb3I7XG4gICAgdGhpcy5jbGVhckNvbG9yID0gZmFsc2U7XG4gICAgdGhpcy5nZXRCbG9ja0NvbG9yKCk7XG4gICAgdGhpcy5uek9uQ2hhbmdlLmVtaXQoeyBjb2xvcjogZ2VuZXJhdGVDb2xvcih2YWx1ZS5jb2xvciksIGZvcm1hdDogdmFsdWUuZm9ybWF0IH0pO1xuICAgIHRoaXMuZm9ybUNvbnRyb2wucGF0Y2hWYWx1ZSh2YWx1ZS5jb2xvcik7XG4gICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gIH1cbn1cbiJdfQ==