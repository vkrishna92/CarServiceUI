/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
/* eslint-disable @angular-eslint/component-selector */
import { NgForOf } from '@angular/common';
import { ChangeDetectionStrategy, Component, EventEmitter, Input, NgZone, Output, ViewChildren, ViewEncapsulation } from '@angular/core';
import { Subject, combineLatest } from 'rxjs';
import { debounceTime, map, startWith, switchMap, takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "ng-zorro-antd/cdk/resize-observer";
export class NzTrMeasureComponent {
    constructor(nzResizeObserver, ngZone) {
        this.nzResizeObserver = nzResizeObserver;
        this.ngZone = ngZone;
        this.listOfMeasureColumn = [];
        this.listOfAutoWidth = new EventEmitter();
        this.destroy$ = new Subject();
    }
    trackByFunc(_, key) {
        return key;
    }
    ngAfterViewInit() {
        this.listOfTdElement.changes
            .pipe(startWith(this.listOfTdElement))
            .pipe(switchMap(list => combineLatest(list.toArray().map((item) => this.nzResizeObserver.observe(item).pipe(map(([entry]) => {
            const { width } = entry.target.getBoundingClientRect();
            return Math.floor(width);
        }))))), debounceTime(16), takeUntil(this.destroy$))
            .subscribe(data => {
            // Caretaker note: we don't have to re-enter the Angular zone each time the stream emits.
            // The below check is necessary to be sure that zone is not nooped through `BootstrapOptions`
            // (`bootstrapModule(AppModule, { ngZone: 'noop' }))`. The `ngZone instanceof NgZone` may return
            // `false` if zone is nooped, since `ngZone` will be an instance of the `NoopNgZone`.
            // The `ResizeObserver` might be also patched through `zone.js/dist/zone-patch-resize-observer`,
            // thus calling `ngZone.run` again will cause another change detection.
            if (this.ngZone instanceof NgZone && NgZone.isInAngularZone()) {
                this.listOfAutoWidth.next(data);
            }
            else {
                this.ngZone.run(() => this.listOfAutoWidth.next(data));
            }
        });
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.7", ngImport: i0, type: NzTrMeasureComponent, deps: [{ token: i1.NzResizeObserver }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.7", type: NzTrMeasureComponent, isStandalone: true, selector: "tr[nz-table-measure-row]", inputs: { listOfMeasureColumn: "listOfMeasureColumn" }, outputs: { listOfAutoWidth: "listOfAutoWidth" }, host: { classAttribute: "ant-table-measure-now" }, viewQueries: [{ propertyName: "listOfTdElement", predicate: ["tdElement"], descendants: true }], ngImport: i0, template: `
    <td
      #tdElement
      class="nz-disable-td"
      style="padding: 0px; border: 0px; height: 0px;"
      *ngFor="let th of listOfMeasureColumn; trackBy: trackByFunc"
    ></td>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.7", ngImport: i0, type: NzTrMeasureComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tr[nz-table-measure-row]',
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    template: `
    <td
      #tdElement
      class="nz-disable-td"
      style="padding: 0px; border: 0px; height: 0px;"
      *ngFor="let th of listOfMeasureColumn; trackBy: trackByFunc"
    ></td>
  `,
                    host: { class: 'ant-table-measure-now' },
                    imports: [NgForOf],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.NzResizeObserver }, { type: i0.NgZone }], propDecorators: { listOfMeasureColumn: [{
                type: Input
            }], listOfAutoWidth: [{
                type: Output
            }], listOfTdElement: [{
                type: ViewChildren,
                args: ['tdElement']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHItbWVhc3VyZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9jb21wb25lbnRzL3RhYmxlL3NyYy90YWJsZS90ci1tZWFzdXJlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFFSCx1REFBdUQ7QUFFdkQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzFDLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUVULFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUVOLE1BQU0sRUFFTixZQUFZLEVBQ1osaUJBQWlCLEVBQ2xCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBYyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzFELE9BQU8sRUFBRSxZQUFZLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQXFCcEYsTUFBTSxPQUFPLG9CQUFvQjtJQUsvQixZQUNVLGdCQUFrQyxFQUNsQyxNQUFjO1FBRGQscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBTmYsd0JBQW1CLEdBQXNCLEVBQUUsQ0FBQztRQUNsQyxvQkFBZSxHQUFHLElBQUksWUFBWSxFQUFZLENBQUM7UUFFMUQsYUFBUSxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7SUFJdkMsQ0FBQztJQUNKLFdBQVcsQ0FBQyxDQUFTLEVBQUUsR0FBVztRQUNoQyxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFDRCxlQUFlO1FBQ2IsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPO2FBQ3pCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2FBQ3JDLElBQUksQ0FDSCxTQUFTLENBQ1AsSUFBSSxDQUFDLEVBQUUsQ0FDTCxhQUFhLENBQ1gsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQWdCLEVBQUUsRUFBRSxDQUN0QyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FDdEMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFO1lBQ2QsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMscUJBQXFCLEVBQUUsQ0FBQztZQUN2RCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0IsQ0FBQyxDQUFDLENBQ0gsQ0FDRixDQUNzQixDQUM1QixFQUNELFlBQVksQ0FBQyxFQUFFLENBQUMsRUFDaEIsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FDekI7YUFDQSxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDaEIseUZBQXlGO1lBQ3pGLDZGQUE2RjtZQUM3RixnR0FBZ0c7WUFDaEcscUZBQXFGO1lBQ3JGLGdHQUFnRztZQUNoRyx1RUFBdUU7WUFDdkUsSUFBSSxJQUFJLENBQUMsTUFBTSxZQUFZLE1BQU0sSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFLEVBQUU7Z0JBQzdELElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2pDO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDeEQ7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFDRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMzQixDQUFDOzhHQWpEVSxvQkFBb0I7a0dBQXBCLG9CQUFvQixpVkFackI7Ozs7Ozs7R0FPVCw0REFFUyxPQUFPOzsyRkFHTixvQkFBb0I7a0JBakJoQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSwwQkFBMEI7b0JBQ3BDLG1CQUFtQixFQUFFLEtBQUs7b0JBQzFCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtvQkFDckMsUUFBUSxFQUFFOzs7Ozs7O0dBT1Q7b0JBQ0QsSUFBSSxFQUFFLEVBQUUsS0FBSyxFQUFFLHVCQUF1QixFQUFFO29CQUN4QyxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUM7b0JBQ2xCLFVBQVUsRUFBRSxJQUFJO2lCQUNqQjswR0FFVSxtQkFBbUI7c0JBQTNCLEtBQUs7Z0JBQ2EsZUFBZTtzQkFBakMsTUFBTTtnQkFDb0IsZUFBZTtzQkFBekMsWUFBWTt1QkFBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgQGFuZ3VsYXItZXNsaW50L2NvbXBvbmVudC1zZWxlY3RvciAqL1xuXG5pbXBvcnQgeyBOZ0Zvck9mIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgVmlld0NoaWxkcmVuLFxuICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIGNvbWJpbmVMYXRlc3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgbWFwLCBzdGFydFdpdGgsIHN3aXRjaE1hcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBOelJlc2l6ZU9ic2VydmVyIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jZGsvcmVzaXplLW9ic2VydmVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndHJbbnotdGFibGUtbWVhc3VyZS1yb3ddJyxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICB0ZW1wbGF0ZTogYFxuICAgIDx0ZFxuICAgICAgI3RkRWxlbWVudFxuICAgICAgY2xhc3M9XCJuei1kaXNhYmxlLXRkXCJcbiAgICAgIHN0eWxlPVwicGFkZGluZzogMHB4OyBib3JkZXI6IDBweDsgaGVpZ2h0OiAwcHg7XCJcbiAgICAgICpuZ0Zvcj1cImxldCB0aCBvZiBsaXN0T2ZNZWFzdXJlQ29sdW1uOyB0cmFja0J5OiB0cmFja0J5RnVuY1wiXG4gICAgPjwvdGQ+XG4gIGAsXG4gIGhvc3Q6IHsgY2xhc3M6ICdhbnQtdGFibGUtbWVhc3VyZS1ub3cnIH0sXG4gIGltcG9ydHM6IFtOZ0Zvck9mXSxcbiAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBOelRyTWVhc3VyZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gIEBJbnB1dCgpIGxpc3RPZk1lYXN1cmVDb2x1bW46IHJlYWRvbmx5IHN0cmluZ1tdID0gW107XG4gIEBPdXRwdXQoKSByZWFkb25seSBsaXN0T2ZBdXRvV2lkdGggPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcltdPigpO1xuICBAVmlld0NoaWxkcmVuKCd0ZEVsZW1lbnQnKSBsaXN0T2ZUZEVsZW1lbnQhOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XG4gIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG56UmVzaXplT2JzZXJ2ZXI6IE56UmVzaXplT2JzZXJ2ZXIsXG4gICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZVxuICApIHt9XG4gIHRyYWNrQnlGdW5jKF86IG51bWJlciwga2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMubGlzdE9mVGRFbGVtZW50LmNoYW5nZXNcbiAgICAgIC5waXBlKHN0YXJ0V2l0aCh0aGlzLmxpc3RPZlRkRWxlbWVudCkpXG4gICAgICAucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKFxuICAgICAgICAgIGxpc3QgPT5cbiAgICAgICAgICAgIGNvbWJpbmVMYXRlc3QoXG4gICAgICAgICAgICAgIGxpc3QudG9BcnJheSgpLm1hcCgoaXRlbTogRWxlbWVudFJlZikgPT5cbiAgICAgICAgICAgICAgICB0aGlzLm56UmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShpdGVtKS5waXBlKFxuICAgICAgICAgICAgICAgICAgbWFwKChbZW50cnldKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGVudHJ5LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iod2lkdGgpO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkgYXMgT2JzZXJ2YWJsZTxudW1iZXJbXT5cbiAgICAgICAgKSxcbiAgICAgICAgZGVib3VuY2VUaW1lKDE2KSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKGRhdGEgPT4ge1xuICAgICAgICAvLyBDYXJldGFrZXIgbm90ZTogd2UgZG9uJ3QgaGF2ZSB0byByZS1lbnRlciB0aGUgQW5ndWxhciB6b25lIGVhY2ggdGltZSB0aGUgc3RyZWFtIGVtaXRzLlxuICAgICAgICAvLyBUaGUgYmVsb3cgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGJlIHN1cmUgdGhhdCB6b25lIGlzIG5vdCBub29wZWQgdGhyb3VnaCBgQm9vdHN0cmFwT3B0aW9uc2BcbiAgICAgICAgLy8gKGBib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlLCB7IG5nWm9uZTogJ25vb3AnIH0pKWAuIFRoZSBgbmdab25lIGluc3RhbmNlb2YgTmdab25lYCBtYXkgcmV0dXJuXG4gICAgICAgIC8vIGBmYWxzZWAgaWYgem9uZSBpcyBub29wZWQsIHNpbmNlIGBuZ1pvbmVgIHdpbGwgYmUgYW4gaW5zdGFuY2Ugb2YgdGhlIGBOb29wTmdab25lYC5cbiAgICAgICAgLy8gVGhlIGBSZXNpemVPYnNlcnZlcmAgbWlnaHQgYmUgYWxzbyBwYXRjaGVkIHRocm91Z2ggYHpvbmUuanMvZGlzdC96b25lLXBhdGNoLXJlc2l6ZS1vYnNlcnZlcmAsXG4gICAgICAgIC8vIHRodXMgY2FsbGluZyBgbmdab25lLnJ1bmAgYWdhaW4gd2lsbCBjYXVzZSBhbm90aGVyIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLm5nWm9uZSBpbnN0YW5jZW9mIE5nWm9uZSAmJiBOZ1pvbmUuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICB0aGlzLmxpc3RPZkF1dG9XaWR0aC5uZXh0KGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB0aGlzLmxpc3RPZkF1dG9XaWR0aC5uZXh0KGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5kZXN0cm95JC5uZXh0KHRydWUpO1xuICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgfVxufVxuIl19