/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
/**
 * QR Code generator library (TypeScript)
 *
 * Copyright (c) Project Nayuki.
 * https://www.nayuki.io/page/qr-code-generator-library
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
'use strict';
var qrcodegen;
(function (qrcodegen) {
    /*---- QR Code symbol class ----*/
    /*
     * A QR Code symbol, which is a type of two-dimension barcode.
     * Invented by Denso Wave and described in the ISO/IEC 18004 standard.
     * Instances of this class represent an immutable square grid of dark and light cells.
     * The class provides static factory functions to create a QR Code from text or binary data.
     * The class covers the QR Code Model 2 specification, supporting all versions (sizes)
     * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.
     *
     * Ways to create a QR Code object:
     * - High level: Take the payload data and call QrCode.encodeText() or QrCode.encodeBinary().
     * - Mid level: Custom-make the list of segments and call QrCode.encodeSegments().
     * - Low level: Custom-make the array of data codeword bytes (including
     *   segment headers and final padding, excluding error correction codewords),
     *   supply the appropriate version number, and call the QrCode() constructor.
     * (Note that all ways require supplying the desired error correction level.)
     */
    class QrCode {
        /*-- Static factory functions (high level) --*/
        // Returns a QR Code representing the given Unicode text string at the given error correction level.
        // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
        // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
        // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
        // ecl argument if it can be done without increasing the version.
        static encodeText(text, ecl) {
            const segs = qrcodegen.QrSegment.makeSegments(text);
            return QrCode.encodeSegments(segs, ecl);
        }
        // Returns a QR Code representing the given binary data at the given error correction level.
        // This function always encodes using the binary segment mode, not any text mode. The maximum number of
        // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
        // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
        static encodeBinary(data, ecl) {
            const seg = qrcodegen.QrSegment.makeBytes(data);
            return QrCode.encodeSegments([seg], ecl);
        }
        /*-- Static factory functions (mid level) --*/
        // Returns a QR Code representing the given segments with the given encoding parameters.
        // The smallest possible QR Code version within the given range is automatically
        // chosen for the output. Iff boostEcl is true, then the ECC level of the result
        // may be higher than the ecl argument if it can be done without increasing the
        // version. The mask number is either between 0 to 7 (inclusive) to force that
        // mask, or -1 to automatically choose an appropriate mask (which may be slow).
        // This function allows the user to create a custom sequence of segments that switches
        // between modes (such as alphanumeric and byte) to encode text in less space.
        // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
        static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
            if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION) ||
                mask < -1 ||
                mask > 7)
                throw new RangeError('Invalid value');
            // Find the minimal version number to use
            let version;
            let dataUsedBits;
            for (version = minVersion;; version++) {
                const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8; // Number of data bits available
                const usedBits = QrSegment.getTotalBits(segs, version);
                if (usedBits <= dataCapacityBits) {
                    dataUsedBits = usedBits;
                    break; // This version number is found to be suitable
                }
                if (version >= maxVersion)
                    // All versions in the range could not fit the given data
                    throw new RangeError('Data too long');
            }
            // Increase the error correction level while the data still fits in the current version number
            for (const newEcl of [QrCode.Ecc.MEDIUM, QrCode.Ecc.QUARTILE, QrCode.Ecc.HIGH]) {
                // From low to high
                if (boostEcl && dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8)
                    ecl = newEcl;
            }
            // Concatenate all segments to create the data bit string
            let bb = [];
            for (const seg of segs) {
                appendBits(seg.mode.modeBits, 4, bb);
                appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
                for (const b of seg.getData())
                    bb.push(b);
            }
            assert(bb.length == dataUsedBits);
            // Add terminator and pad up to a byte if applicable
            const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;
            assert(bb.length <= dataCapacityBits);
            appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
            appendBits(0, (8 - (bb.length % 8)) % 8, bb);
            assert(bb.length % 8 == 0);
            // Pad with alternating bytes until data capacity is reached
            for (let padByte = 0xec; bb.length < dataCapacityBits; padByte ^= 0xec ^ 0x11)
                appendBits(padByte, 8, bb);
            // Pack bits into bytes in big endian
            let dataCodewords = [];
            while (dataCodewords.length * 8 < bb.length)
                dataCodewords.push(0);
            bb.forEach((b, i) => (dataCodewords[i >>> 3] |= b << (7 - (i & 7))));
            // Create the QR Code object
            return new QrCode(version, ecl, dataCodewords, mask);
        }
        /*-- Constructor (low level) and fields --*/
        // Creates a new QR Code with the given version number,
        // error correction level, data codeword bytes, and mask number.
        // This is a low-level API that most users should not use directly.
        // A mid-level API is the encodeSegments() function.
        constructor(
        // The version number of this QR Code, which is between 1 and 40 (inclusive).
        // This determines the size of this barcode.
        version, 
        // The error correction level used in this QR Code.
        errorCorrectionLevel, dataCodewords, msk) {
            this.version = version;
            this.errorCorrectionLevel = errorCorrectionLevel;
            // The modules of this QR Code (false = light, true = dark).
            // Immutable after constructor finishes. Accessed through getModule().
            this.modules = [];
            // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.
            this.isFunction = [];
            // Check scalar arguments
            if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION)
                throw new RangeError('Version value out of range');
            if (msk < -1 || msk > 7)
                throw new RangeError('Mask value out of range');
            this.size = version * 4 + 17;
            // Initialize both grids to be size*size arrays of Boolean false
            let row = [];
            for (let i = 0; i < this.size; i++)
                row.push(false);
            for (let i = 0; i < this.size; i++) {
                this.modules.push(row.slice()); // Initially all light
                this.isFunction.push(row.slice());
            }
            // Compute ECC, draw modules
            this.drawFunctionPatterns();
            const allCodewords = this.addEccAndInterleave(dataCodewords);
            this.drawCodewords(allCodewords);
            // Do masking
            if (msk == -1) {
                // Automatically choose best mask
                let minPenalty = 1000000000;
                for (let i = 0; i < 8; i++) {
                    this.applyMask(i);
                    this.drawFormatBits(i);
                    const penalty = this.getPenaltyScore();
                    if (penalty < minPenalty) {
                        msk = i;
                        minPenalty = penalty;
                    }
                    this.applyMask(i); // Undoes the mask due to XOR
                }
            }
            assert(msk >= 0 && msk <= 7);
            this.mask = msk;
            this.applyMask(msk); // Apply the final choice of mask
            this.drawFormatBits(msk); // Overwrite old format bits
            this.isFunction = [];
        }
        /*-- Accessor methods --*/
        // Returns the color of the module (pixel) at the given coordinates, which is false
        // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
        // If the given coordinates are out of bounds, then false (light) is returned.
        getModule(x, y) {
            return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];
        }
        // Modified to expose modules for easy access
        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
        getModules() {
            return this.modules;
        }
        /*-- Private helper methods for constructor: Drawing function modules --*/
        // Reads this object's version field, and draws and marks all function modules.
        drawFunctionPatterns() {
            // Draw horizontal and vertical timing patterns
            for (let i = 0; i < this.size; i++) {
                this.setFunctionModule(6, i, i % 2 == 0);
                this.setFunctionModule(i, 6, i % 2 == 0);
            }
            // Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)
            this.drawFinderPattern(3, 3);
            this.drawFinderPattern(this.size - 4, 3);
            this.drawFinderPattern(3, this.size - 4);
            // Draw numerous alignment patterns
            const alignPatPos = this.getAlignmentPatternPositions();
            const numAlign = alignPatPos.length;
            for (let i = 0; i < numAlign; i++) {
                for (let j = 0; j < numAlign; j++) {
                    // Don't draw on the three finder corners
                    if (!((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0)))
                        this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
                }
            }
            // Draw configuration data
            this.drawFormatBits(0); // Dummy mask value; overwritten later in the constructor
            this.drawVersion();
        }
        // Draws two copies of the format bits (with its own error correction code)
        // based on the given mask and this object's error correction level field.
        drawFormatBits(mask) {
            // Calculate error correction code and pack bits
            const data = (this.errorCorrectionLevel.formatBits << 3) | mask; // errCorrLvl is uint2, mask is uint3
            let rem = data;
            for (let i = 0; i < 10; i++)
                rem = (rem << 1) ^ ((rem >>> 9) * 0x537);
            const bits = ((data << 10) | rem) ^ 0x5412; // uint15
            assert(bits >>> 15 == 0);
            // Draw first copy
            for (let i = 0; i <= 5; i++)
                this.setFunctionModule(8, i, getBit(bits, i));
            this.setFunctionModule(8, 7, getBit(bits, 6));
            this.setFunctionModule(8, 8, getBit(bits, 7));
            this.setFunctionModule(7, 8, getBit(bits, 8));
            for (let i = 9; i < 15; i++)
                this.setFunctionModule(14 - i, 8, getBit(bits, i));
            // Draw second copy
            for (let i = 0; i < 8; i++)
                this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
            for (let i = 8; i < 15; i++)
                this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
            this.setFunctionModule(8, this.size - 8, true); // Always dark
        }
        // Draws two copies of the version bits (with its own error correction code),
        // based on this object's version field, iff 7 <= version <= 40.
        drawVersion() {
            if (this.version < 7)
                return;
            // Calculate error correction code and pack bits
            let rem = this.version; // version is uint6, in the range [7, 40]
            for (let i = 0; i < 12; i++)
                rem = (rem << 1) ^ ((rem >>> 11) * 0x1f25);
            const bits = (this.version << 12) | rem; // uint18
            assert(bits >>> 18 == 0);
            // Draw two copies
            for (let i = 0; i < 18; i++) {
                const color = getBit(bits, i);
                const a = this.size - 11 + (i % 3);
                const b = Math.floor(i / 3);
                this.setFunctionModule(a, b, color);
                this.setFunctionModule(b, a, color);
            }
        }
        // Draws a 9*9 finder pattern including the border separator,
        // with the center module at (x, y). Modules can be out of bounds.
        drawFinderPattern(x, y) {
            for (let dy = -4; dy <= 4; dy++) {
                for (let dx = -4; dx <= 4; dx++) {
                    const dist = Math.max(Math.abs(dx), Math.abs(dy)); // Chebyshev/infinity norm
                    const xx = x + dx;
                    const yy = y + dy;
                    if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size)
                        this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
                }
            }
        }
        // Draws a 5*5 alignment pattern, with the center module
        // at (x, y). All modules must be in bounds.
        drawAlignmentPattern(x, y) {
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++)
                    this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
            }
        }
        // Sets the color of a module and marks it as a function module.
        // Only used by the constructor. Coordinates must be in bounds.
        setFunctionModule(x, y, isDark) {
            this.modules[y][x] = isDark;
            this.isFunction[y][x] = true;
        }
        /*-- Private helper methods for constructor: Codewords and masking --*/
        // Returns a new byte string representing the given data with the appropriate error correction
        // codewords appended to it, based on this object's version and error correction level.
        addEccAndInterleave(data) {
            const ver = this.version;
            const ecl = this.errorCorrectionLevel;
            if (data.length != QrCode.getNumDataCodewords(ver, ecl))
                throw new RangeError('Invalid argument');
            // Calculate parameter numbers
            const numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
            const blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
            const rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8);
            const numShortBlocks = numBlocks - (rawCodewords % numBlocks);
            const shortBlockLen = Math.floor(rawCodewords / numBlocks);
            // Split data into blocks and append ECC to each block
            let blocks = [];
            const rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen);
            for (let i = 0, k = 0; i < numBlocks; i++) {
                let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
                k += dat.length;
                const ecc = QrCode.reedSolomonComputeRemainder(dat, rsDiv);
                if (i < numShortBlocks)
                    dat.push(0);
                blocks.push(dat.concat(ecc));
            }
            // Interleave (not concatenate) the bytes from every block into a single sequence
            let result = [];
            for (let i = 0; i < blocks[0].length; i++) {
                blocks.forEach((block, j) => {
                    // Skip the padding byte in short blocks
                    if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)
                        result.push(block[i]);
                });
            }
            assert(result.length == rawCodewords);
            return result;
        }
        // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
        // data area of this QR Code. Function modules need to be marked off before this is called.
        drawCodewords(data) {
            if (data.length != Math.floor(QrCode.getNumRawDataModules(this.version) / 8))
                throw new RangeError('Invalid argument');
            let i = 0; // Bit index into the data
            // Do the funny zigzag scan
            for (let right = this.size - 1; right >= 1; right -= 2) {
                // Index of right column in each column pair
                if (right == 6)
                    right = 5;
                for (let vert = 0; vert < this.size; vert++) {
                    // Vertical counter
                    for (let j = 0; j < 2; j++) {
                        const x = right - j; // Actual x coordinate
                        const upward = ((right + 1) & 2) == 0;
                        const y = upward ? this.size - 1 - vert : vert; // Actual y coordinate
                        if (!this.isFunction[y][x] && i < data.length * 8) {
                            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
                            i++;
                        }
                        // If this QR Code has any remainder bits (0 to 7), they were assigned as
                        // 0/false/light by the constructor and are left unchanged by this method
                    }
                }
            }
            assert(i == data.length * 8);
        }
        // XORs the codeword modules in this QR Code with the given mask pattern.
        // The function modules must be marked and the codeword bits must be drawn
        // before masking. Due to the arithmetic of XOR, calling applyMask() with
        // the same mask value a second time will undo the mask. A final well-formed
        // QR Code needs exactly one (not zero, two, etc.) mask applied.
        applyMask(mask) {
            if (mask < 0 || mask > 7)
                throw new RangeError('Mask value out of range');
            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    let invert;
                    switch (mask) {
                        case 0:
                            invert = (x + y) % 2 == 0;
                            break;
                        case 1:
                            invert = y % 2 == 0;
                            break;
                        case 2:
                            invert = x % 3 == 0;
                            break;
                        case 3:
                            invert = (x + y) % 3 == 0;
                            break;
                        case 4:
                            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
                            break;
                        case 5:
                            invert = ((x * y) % 2) + ((x * y) % 3) == 0;
                            break;
                        case 6:
                            invert = (((x * y) % 2) + ((x * y) % 3)) % 2 == 0;
                            break;
                        case 7:
                            invert = (((x + y) % 2) + ((x * y) % 3)) % 2 == 0;
                            break;
                        default:
                            throw new Error('Unreachable');
                    }
                    if (!this.isFunction[y][x] && invert)
                        this.modules[y][x] = !this.modules[y][x];
                }
            }
        }
        // Calculates and returns the penalty score based on state of this QR Code's current modules.
        // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
        getPenaltyScore() {
            let result = 0;
            // Adjacent modules in row having same color, and finder-like patterns
            for (let y = 0; y < this.size; y++) {
                let runColor = false;
                let runX = 0;
                let runHistory = [0, 0, 0, 0, 0, 0, 0];
                for (let x = 0; x < this.size; x++) {
                    if (this.modules[y][x] == runColor) {
                        runX++;
                        if (runX == 5)
                            result += QrCode.PENALTY_N1;
                        else if (runX > 5)
                            result++;
                    }
                    else {
                        this.finderPenaltyAddHistory(runX, runHistory);
                        if (!runColor)
                            result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
                        runColor = this.modules[y][x];
                        runX = 1;
                    }
                }
                result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode.PENALTY_N3;
            }
            // Adjacent modules in column having same color, and finder-like patterns
            for (let x = 0; x < this.size; x++) {
                let runColor = false;
                let runY = 0;
                let runHistory = [0, 0, 0, 0, 0, 0, 0];
                for (let y = 0; y < this.size; y++) {
                    if (this.modules[y][x] == runColor) {
                        runY++;
                        if (runY == 5)
                            result += QrCode.PENALTY_N1;
                        else if (runY > 5)
                            result++;
                    }
                    else {
                        this.finderPenaltyAddHistory(runY, runHistory);
                        if (!runColor)
                            result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
                        runColor = this.modules[y][x];
                        runY = 1;
                    }
                }
                result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * QrCode.PENALTY_N3;
            }
            // 2*2 blocks of modules having same color
            for (let y = 0; y < this.size - 1; y++) {
                for (let x = 0; x < this.size - 1; x++) {
                    const color = this.modules[y][x];
                    if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1])
                        result += QrCode.PENALTY_N2;
                }
            }
            // Balance of dark and light modules
            let dark = 0;
            for (const row of this.modules)
                dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
            const total = this.size * this.size; // Note that size is odd, so dark/total != 1/2
            // Compute the smallest integer k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%
            const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
            assert(k >= 0 && k <= 9);
            result += k * QrCode.PENALTY_N4;
            assert(result >= 0 && result <= 2568888); // Non-tight upper bound based on default values of PENALTY_N1, ..., N4
            return result;
        }
        /*-- Private helper functions --*/
        // Returns an ascending list of positions of alignment patterns for this version number.
        // Each position is in the range [0,177), and are used on both the x and y axes.
        // This could be implemented as lookup table of 40 variable-length lists of integers.
        getAlignmentPatternPositions() {
            if (this.version == 1)
                return [];
            else {
                const numAlign = Math.floor(this.version / 7) + 2;
                const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
                let result = [6];
                for (let pos = this.size - 7; result.length < numAlign; pos -= step)
                    result.splice(1, 0, pos);
                return result;
            }
        }
        // Returns the number of data bits that can be stored in a QR Code of the given version number, after
        // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
        // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
        static getNumRawDataModules(ver) {
            if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION)
                throw new RangeError('Version number out of range');
            let result = (16 * ver + 128) * ver + 64;
            if (ver >= 2) {
                const numAlign = Math.floor(ver / 7) + 2;
                result -= (25 * numAlign - 10) * numAlign - 55;
                if (ver >= 7)
                    result -= 36;
            }
            assert(result >= 208 && result <= 29648);
            return result;
        }
        // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
        // QR Code of the given version number and error correction level, with remainder bits discarded.
        // This stateless pure function could be implemented as a (40*4)-cell lookup table.
        static getNumDataCodewords(ver, ecl) {
            return (Math.floor(QrCode.getNumRawDataModules(ver) / 8) -
                QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver]);
        }
        // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
        // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
        static reedSolomonComputeDivisor(degree) {
            if (degree < 1 || degree > 255)
                throw new RangeError('Degree out of range');
            // Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.
            // For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array [255, 8, 93].
            let result = [];
            for (let i = 0; i < degree - 1; i++)
                result.push(0);
            result.push(1); // Start off with the monomial x^0
            // Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),
            // and drop the highest monomial term which is always 1x^degree.
            // Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).
            let root = 1;
            for (let i = 0; i < degree; i++) {
                // Multiply the current product by (x - r^i)
                for (let j = 0; j < result.length; j++) {
                    result[j] = QrCode.reedSolomonMultiply(result[j], root);
                    if (j + 1 < result.length)
                        result[j] ^= result[j + 1];
                }
                root = QrCode.reedSolomonMultiply(root, 0x02);
            }
            return result;
        }
        // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
        static reedSolomonComputeRemainder(data, divisor) {
            let result = divisor.map(_ => 0);
            for (const b of data) {
                // Polynomial division
                const factor = b ^ result.shift();
                result.push(0);
                divisor.forEach((coef, i) => (result[i] ^= QrCode.reedSolomonMultiply(coef, factor)));
            }
            return result;
        }
        // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
        // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
        static reedSolomonMultiply(x, y) {
            if (x >>> 8 != 0 || y >>> 8 != 0)
                throw new RangeError('Byte out of range');
            // Russian peasant multiplication
            let z = 0;
            for (let i = 7; i >= 0; i--) {
                z = (z << 1) ^ ((z >>> 7) * 0x11d);
                z ^= ((y >>> i) & 1) * x;
            }
            assert(z >>> 8 == 0);
            return z;
        }
        // Can only be called immediately after a light run is added, and
        // returns either 0, 1, or 2. A helper function for getPenaltyScore().
        finderPenaltyCountPatterns(runHistory) {
            const n = runHistory[1];
            assert(n <= this.size * 3);
            const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
            return ((core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) +
                (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0));
        }
        // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
        finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
            if (currentRunColor) {
                // Terminate dark run
                this.finderPenaltyAddHistory(currentRunLength, runHistory);
                currentRunLength = 0;
            }
            currentRunLength += this.size; // Add light border to final run
            this.finderPenaltyAddHistory(currentRunLength, runHistory);
            return this.finderPenaltyCountPatterns(runHistory);
        }
        // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
        finderPenaltyAddHistory(currentRunLength, runHistory) {
            if (runHistory[0] == 0)
                currentRunLength += this.size; // Add light border to initial run
            runHistory.pop();
            runHistory.unshift(currentRunLength);
        }
        /*-- Constants and tables --*/
        // The minimum version number supported in the QR Code Model 2 standard.
        static { this.MIN_VERSION = 1; }
        // The maximum version number supported in the QR Code Model 2 standard.
        static { this.MAX_VERSION = 40; }
        // For use in getPenaltyScore(), when evaluating which mask is best.
        static { this.PENALTY_N1 = 3; }
        static { this.PENALTY_N2 = 3; }
        static { this.PENALTY_N3 = 40; }
        static { this.PENALTY_N4 = 10; }
        static { this.ECC_CODEWORDS_PER_BLOCK = [
            // Version: (note that index 0 is for padding, and is set to an illegal value)
            //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
            [
                -1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30,
                30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30
            ],
            [
                -1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28,
                28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28
            ],
            [
                -1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30,
                30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30
            ],
            [
                -1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30,
                30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30
            ] // High
        ]; }
        static { this.NUM_ERROR_CORRECTION_BLOCKS = [
            // Version: (note that index 0 is for padding, and is set to an illegal value)
            //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
            [
                -1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18,
                19, 19, 20, 21, 22, 24, 25
            ],
            [
                -1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29,
                31, 33, 35, 37, 38, 40, 43, 45, 47, 49
            ],
            [
                -1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40,
                43, 45, 48, 51, 53, 56, 59, 62, 65, 68
            ],
            [
                -1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45,
                48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81
            ] // High
        ]; }
    }
    qrcodegen.QrCode = QrCode;
    // Appends the given number of low-order bits of the given value
    // to the given buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.
    function appendBits(val, len, bb) {
        if (len < 0 || len > 31 || val >>> len != 0)
            throw new RangeError('Value out of range');
        for (let i = len - 1; i >= 0; i-- // Append bit by bit
        )
            bb.push((val >>> i) & 1);
    }
    // Returns true iff the i'th bit of x is set to 1.
    function getBit(x, i) {
        return ((x >>> i) & 1) != 0;
    }
    // Throws an exception if the given condition is false.
    function assert(cond) {
        if (!cond)
            throw new Error('Assertion error');
    }
    /*---- Data segment class ----*/
    /*
     * A segment of character/binary/control data in a QR Code symbol.
     * Instances of this class are immutable.
     * The mid-level way to create a segment is to take the payload data
     * and call a static factory function such as QrSegment.makeNumeric().
     * The low-level way to create a segment is to custom-make the bit buffer
     * and call the QrSegment() constructor with appropriate values.
     * This segment class imposes no length restrictions, but QR Codes have restrictions.
     * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.
     * Any segment longer than this is meaningless for the purpose of generating QR Codes.
     */
    class QrSegment {
        /*-- Static factory functions (mid level) --*/
        // Returns a segment representing the given binary data encoded in
        // byte mode. All input byte arrays are acceptable. Any text string
        // can be converted to UTF-8 bytes and encoded as a byte mode segment.
        static makeBytes(data) {
            let bb = [];
            for (const b of data)
                appendBits(b, 8, bb);
            return new QrSegment(QrSegment.Mode.BYTE, data.length, bb);
        }
        // Returns a segment representing the given string of decimal digits encoded in numeric mode.
        static makeNumeric(digits) {
            if (!QrSegment.isNumeric(digits))
                throw new RangeError('String contains non-numeric characters');
            let bb = [];
            for (let i = 0; i < digits.length;) {
                // Consume up to 3 digits per iteration
                const n = Math.min(digits.length - i, 3);
                appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
                i += n;
            }
            return new QrSegment(QrSegment.Mode.NUMERIC, digits.length, bb);
        }
        // Returns a segment representing the given text string encoded in alphanumeric mode.
        // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
        // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
        static makeAlphanumeric(text) {
            if (!QrSegment.isAlphanumeric(text))
                throw new RangeError('String contains unencodable characters in alphanumeric mode');
            let bb = [];
            let i;
            for (i = 0; i + 2 <= text.length; i += 2) {
                // Process groups of 2
                let temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
                temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
                appendBits(temp, 11, bb);
            }
            if (i < text.length)
                // 1 character remaining
                appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
            return new QrSegment(QrSegment.Mode.ALPHANUMERIC, text.length, bb);
        }
        // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
        // The result may use various segment modes and switch modes to optimize the length of the bit stream.
        static makeSegments(text) {
            // Select the most efficient segment encoding automatically
            if (text == '')
                return [];
            else if (QrSegment.isNumeric(text))
                return [QrSegment.makeNumeric(text)];
            else if (QrSegment.isAlphanumeric(text))
                return [QrSegment.makeAlphanumeric(text)];
            else
                return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];
        }
        // Returns a segment representing an Extended Channel Interpretation
        // (ECI) designator with the given assignment value.
        static makeEci(assignVal) {
            let bb = [];
            if (assignVal < 0)
                throw new RangeError('ECI assignment value out of range');
            else if (assignVal < 1 << 7)
                appendBits(assignVal, 8, bb);
            else if (assignVal < 1 << 14) {
                appendBits(0b10, 2, bb);
                appendBits(assignVal, 14, bb);
            }
            else if (assignVal < 1000000) {
                appendBits(0b110, 3, bb);
                appendBits(assignVal, 21, bb);
            }
            else
                throw new RangeError('ECI assignment value out of range');
            return new QrSegment(QrSegment.Mode.ECI, 0, bb);
        }
        // Tests whether the given string can be encoded as a segment in numeric mode.
        // A string is encodable iff each character is in the range 0 to 9.
        static isNumeric(text) {
            return QrSegment.NUMERIC_REGEX.test(text);
        }
        // Tests whether the given string can be encoded as a segment in alphanumeric mode.
        // A string is encodable iff each character is in the following set: 0 to 9, A to Z
        // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
        static isAlphanumeric(text) {
            return QrSegment.ALPHANUMERIC_REGEX.test(text);
        }
        /*-- Constructor (low level) and fields --*/
        // Creates a new QR Code segment with the given attributes and data.
        // The character count (numChars) must agree with the mode and the bit buffer length,
        // but the constraint isn't checked. The given bit buffer is cloned and stored.
        constructor(
        // The mode indicator of this segment.
        mode, 
        // The length of this segment's unencoded data. Measured in characters for
        // numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.
        // Always zero or positive. Not the same as the data's bit length.
        numChars, 
        // The data bits of this segment. Accessed through getData().
        bitData) {
            this.mode = mode;
            this.numChars = numChars;
            this.bitData = bitData;
            if (numChars < 0)
                throw new RangeError('Invalid argument');
            this.bitData = bitData.slice(); // Make defensive copy
        }
        /*-- Methods --*/
        // Returns a new copy of the data bits of this segment.
        getData() {
            return this.bitData.slice(); // Make defensive copy
        }
        // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
        // the given version. The result is infinity if a segment has too many characters to fit its length field.
        static getTotalBits(segs, version) {
            let result = 0;
            for (const seg of segs) {
                const ccbits = seg.mode.numCharCountBits(version);
                if (seg.numChars >= 1 << ccbits)
                    return Infinity; // The segment's length doesn't fit the field's bit width
                result += 4 + ccbits + seg.bitData.length;
            }
            return result;
        }
        // Returns a new array of bytes representing the given string encoded in UTF-8.
        static toUtf8ByteArray(str) {
            str = encodeURI(str);
            let result = [];
            for (let i = 0; i < str.length; i++) {
                if (str.charAt(i) != '%')
                    result.push(str.charCodeAt(i));
                else {
                    result.push(parseInt(str.substring(i + 1, i + 3), 16));
                    i += 2;
                }
            }
            return result;
        }
        /*-- Constants --*/
        // Describes precisely all strings that are encodable in numeric mode.
        static { this.NUMERIC_REGEX = /^[0-9]*$/; }
        // Describes precisely all strings that are encodable in alphanumeric mode.
        static { this.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/; }
        // The set of all legal characters in alphanumeric mode,
        // where each character value maps to the index in the string.
        static { this.ALPHANUMERIC_CHARSET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'; }
    }
    qrcodegen.QrSegment = QrSegment;
})(qrcodegen || (qrcodegen = {}));
/*---- Public helper enumeration ----*/
(function (qrcodegen) {
    var QrCode;
    (function (QrCode) {
        /*
         * The error correction level in a QR Code symbol. Immutable.
         */
        class Ecc {
            /*-- Constants --*/
            static { this.LOW = new Ecc(0, 1); } // The QR Code can tolerate about  7% erroneous codewords
            static { this.MEDIUM = new Ecc(1, 0); } // The QR Code can tolerate about 15% erroneous codewords
            static { this.QUARTILE = new Ecc(2, 3); } // The QR Code can tolerate about 25% erroneous codewords
            static { this.HIGH = new Ecc(3, 2); } // The QR Code can tolerate about 30% erroneous codewords
            /*-- Constructor and fields --*/
            constructor(
            // In the range 0 to 3 (unsigned 2-bit integer).
            ordinal, 
            // (Package-private) In the range 0 to 3 (unsigned 2-bit integer).
            formatBits) {
                this.ordinal = ordinal;
                this.formatBits = formatBits;
            }
        }
        QrCode.Ecc = Ecc;
    })(QrCode = qrcodegen.QrCode || (qrcodegen.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
/*---- Public helper enumeration ----*/
(function (qrcodegen) {
    var QrSegment;
    (function (QrSegment) {
        /*
         * Describes how a segment's data bits are interpreted. Immutable.
         */
        class Mode {
            /*-- Constants --*/
            static { this.NUMERIC = new Mode(0x1, [10, 12, 14]); }
            static { this.ALPHANUMERIC = new Mode(0x2, [9, 11, 13]); }
            static { this.BYTE = new Mode(0x4, [8, 16, 16]); }
            static { this.KANJI = new Mode(0x8, [8, 10, 12]); }
            static { this.ECI = new Mode(0x7, [0, 0, 0]); }
            /*-- Constructor and fields --*/
            constructor(
            // The mode indicator bits, which is a uint4 value (range 0 to 15).
            modeBits, 
            // Number of character count bits for three different version ranges.
            numBitsCharCount) {
                this.modeBits = modeBits;
                this.numBitsCharCount = numBitsCharCount;
            }
            /*-- Method --*/
            // (Package-private) Returns the bit width of the character count field for a segment in
            // this mode in a QR Code at the given version number. The result is in the range [0, 16].
            numCharCountBits(ver) {
                return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
            }
        }
        QrSegment.Mode = Mode;
    })(QrSegment = qrcodegen.QrSegment || (qrcodegen.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
// Modification to export for actual use
export default qrcodegen;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXJjb2RlZ2VuLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vY29tcG9uZW50cy9xci1jb2RlL3FyY29kZWdlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1Qkc7QUFFSCxZQUFZLENBQUM7QUFFYixJQUFVLFNBQVMsQ0EwMUJsQjtBQTExQkQsV0FBVSxTQUFTO0lBS2pCLGtDQUFrQztJQUVsQzs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSCxNQUFhLE1BQU07UUFDakIsK0NBQStDO1FBRS9DLG9HQUFvRztRQUNwRywyR0FBMkc7UUFDM0csK0dBQStHO1FBQy9HLDZHQUE2RztRQUM3RyxpRUFBaUU7UUFDMUQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFZLEVBQUUsR0FBZTtZQUNwRCxNQUFNLElBQUksR0FBZ0IsU0FBUyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDakUsT0FBTyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMxQyxDQUFDO1FBRUQsNEZBQTRGO1FBQzVGLHVHQUF1RztRQUN2Ryx1R0FBdUc7UUFDdkcsb0hBQW9IO1FBQzdHLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBc0IsRUFBRSxHQUFlO1lBQ2hFLE1BQU0sR0FBRyxHQUFjLFNBQVMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzNELE9BQU8sTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzNDLENBQUM7UUFFRCw4Q0FBOEM7UUFFOUMsd0ZBQXdGO1FBQ3hGLGdGQUFnRjtRQUNoRixnRkFBZ0Y7UUFDaEYsK0VBQStFO1FBQy9FLDhFQUE4RTtRQUM5RSwrRUFBK0U7UUFDL0Usc0ZBQXNGO1FBQ3RGLDhFQUE4RTtRQUM5RSxrRkFBa0Y7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O2dCQUNsQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDbEMsSUFBSSxNQUFlLENBQUM7b0JBQ3BCLFFBQVEsSUFBSSxFQUFFO3dCQUNaLEtBQUssQ0FBQzs0QkFDSixNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzs0QkFDMUIsTUFBTTt3QkFDUixLQUFLLENBQUM7NEJBQ0osTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDOzRCQUNwQixNQUFNO3dCQUNSLEtBQUssQ0FBQzs0QkFDSixNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7NEJBQ3BCLE1BQU07d0JBQ1IsS0FBSyxDQUFDOzRCQUNKLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDOzRCQUMxQixNQUFNO3dCQUNSLEtBQUssQ0FBQzs0QkFDSixNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7NEJBQzFELE1BQU07d0JBQ1IsS0FBSyxDQUFDOzRCQUNKLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDOzRCQUM1QyxNQUFNO3dCQUNSLEtBQUssQ0FBQzs0QkFDSixNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdB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QUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7YUFDbkQ7WUFDRDtnQkFDRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7Z0JBQzlHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7YUFDbkQ7WUFDRDtnQkFDRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7Z0JBQzlHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7YUFDbkQ7WUFDRDtnQkFDRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7Z0JBQzlHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7YUFDbkQsQ0FBQyxPQUFPO1NBQ1YsQUFuQjhDLENBbUI3QztpQkFFc0IsZ0NBQTJCLEdBQVk7WUFDN0QsOEVBQThFO1lBQzlFLG1MQUFtTDtZQUNuTDtnQkFDRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7Z0JBQy9HLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7YUFDM0I7WUFDRDtnQkFDRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7Z0JBQzVHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7YUFDdkM7WUFDRDtnQkFDRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7Z0JBQy9HLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7YUFD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Q0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDM0QsQ0FBQzs7UUF4QlUsY0FBSSxPQXlCaEIsQ0FBQTtJQUNILENBQUMsRUFoQ21CLFNBQVMsR0FBVCxtQkFBUyxLQUFULG1CQUFTLFFBZ0M1QjtBQUFELENBQUMsRUFoQ1MsU0FBUyxLQUFULFNBQVMsUUFnQ2xCO0FBRUQsd0NBQXdDO0FBQ3hDLGVBQWUsU0FBUyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuLyoqXG4gKiBRUiBDb2RlIGdlbmVyYXRvciBsaWJyYXJ5IChUeXBlU2NyaXB0KVxuICpcbiAqIENvcHlyaWdodCAoYykgUHJvamVjdCBOYXl1a2kuXG4gKiBodHRwczovL3d3dy5uYXl1a2kuaW8vcGFnZS9xci1jb2RlLWdlbmVyYXRvci1saWJyYXJ5XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm5hbWVzcGFjZSBxcmNvZGVnZW4ge1xuICB0eXBlIGJpdCA9IG51bWJlcjtcbiAgdHlwZSBieXRlID0gbnVtYmVyO1xuICB0eXBlIGludCA9IG51bWJlcjtcblxuICAvKi0tLS0gUVIgQ29kZSBzeW1ib2wgY2xhc3MgLS0tLSovXG5cbiAgLypcbiAgICogQSBRUiBDb2RlIHN5bWJvbCwgd2hpY2ggaXMgYSB0eXBlIG9mIHR3by1kaW1lbnNpb24gYmFyY29kZS5cbiAgICogSW52ZW50ZWQgYnkgRGVuc28gV2F2ZSBhbmQgZGVzY3JpYmVkIGluIHRoZSBJU08vSUVDIDE4MDA0IHN0YW5kYXJkLlxuICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgYW4gaW1tdXRhYmxlIHNxdWFyZSBncmlkIG9mIGRhcmsgYW5kIGxpZ2h0IGNlbGxzLlxuICAgKiBUaGUgY2xhc3MgcHJvdmlkZXMgc3RhdGljIGZhY3RvcnkgZnVuY3Rpb25zIHRvIGNyZWF0ZSBhIFFSIENvZGUgZnJvbSB0ZXh0IG9yIGJpbmFyeSBkYXRhLlxuICAgKiBUaGUgY2xhc3MgY292ZXJzIHRoZSBRUiBDb2RlIE1vZGVsIDIgc3BlY2lmaWNhdGlvbiwgc3VwcG9ydGluZyBhbGwgdmVyc2lvbnMgKHNpemVzKVxuICAgKiBmcm9tIDEgdG8gNDAsIGFsbCA0IGVycm9yIGNvcnJlY3Rpb24gbGV2ZWxzLCBhbmQgNCBjaGFyYWN0ZXIgZW5jb2RpbmcgbW9kZXMuXG4gICAqXG4gICAqIFdheXMgdG8gY3JlYXRlIGEgUVIgQ29kZSBvYmplY3Q6XG4gICAqIC0gSGlnaCBsZXZlbDogVGFrZSB0aGUgcGF5bG9hZCBkYXRhIGFuZCBjYWxsIFFyQ29kZS5lbmNvZGVUZXh0KCkgb3IgUXJDb2RlLmVuY29kZUJpbmFyeSgpLlxuICAgKiAtIE1pZCBsZXZlbDogQ3VzdG9tLW1ha2UgdGhlIGxpc3Qgb2Ygc2VnbWVudHMgYW5kIGNhbGwgUXJDb2RlLmVuY29kZVNlZ21lbnRzKCkuXG4gICAqIC0gTG93IGxldmVsOiBDdXN0b20tbWFrZSB0aGUgYXJyYXkgb2YgZGF0YSBjb2Rld29yZCBieXRlcyAoaW5jbHVkaW5nXG4gICAqICAgc2VnbWVudCBoZWFkZXJzIGFuZCBmaW5hbCBwYWRkaW5nLCBleGNsdWRpbmcgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMpLFxuICAgKiAgIHN1cHBseSB0aGUgYXBwcm9wcmlhdGUgdmVyc2lvbiBudW1iZXIsIGFuZCBjYWxsIHRoZSBRckNvZGUoKSBjb25zdHJ1Y3Rvci5cbiAgICogKE5vdGUgdGhhdCBhbGwgd2F5cyByZXF1aXJlIHN1cHBseWluZyB0aGUgZGVzaXJlZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsLilcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBRckNvZGUge1xuICAgIC8qLS0gU3RhdGljIGZhY3RvcnkgZnVuY3Rpb25zIChoaWdoIGxldmVsKSAtLSovXG5cbiAgICAvLyBSZXR1cm5zIGEgUVIgQ29kZSByZXByZXNlbnRpbmcgdGhlIGdpdmVuIFVuaWNvZGUgdGV4dCBzdHJpbmcgYXQgdGhlIGdpdmVuIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwuXG4gICAgLy8gQXMgYSBjb25zZXJ2YXRpdmUgdXBwZXIgYm91bmQsIHRoaXMgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byBzdWNjZWVkIGZvciBzdHJpbmdzIHRoYXQgaGF2ZSA3Mzggb3IgZmV3ZXJcbiAgICAvLyBVbmljb2RlIGNvZGUgcG9pbnRzIChub3QgVVRGLTE2IGNvZGUgdW5pdHMpIGlmIHRoZSBsb3cgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBpcyB1c2VkLiBUaGUgc21hbGxlc3QgcG9zc2libGVcbiAgICAvLyBRUiBDb2RlIHZlcnNpb24gaXMgYXV0b21hdGljYWxseSBjaG9zZW4gZm9yIHRoZSBvdXRwdXQuIFRoZSBFQ0MgbGV2ZWwgb2YgdGhlIHJlc3VsdCBtYXkgYmUgaGlnaGVyIHRoYW4gdGhlXG4gICAgLy8gZWNsIGFyZ3VtZW50IGlmIGl0IGNhbiBiZSBkb25lIHdpdGhvdXQgaW5jcmVhc2luZyB0aGUgdmVyc2lvbi5cbiAgICBwdWJsaWMgc3RhdGljIGVuY29kZVRleHQodGV4dDogc3RyaW5nLCBlY2w6IFFyQ29kZS5FY2MpOiBRckNvZGUge1xuICAgICAgY29uc3Qgc2VnczogUXJTZWdtZW50W10gPSBxcmNvZGVnZW4uUXJTZWdtZW50Lm1ha2VTZWdtZW50cyh0ZXh0KTtcbiAgICAgIHJldHVybiBRckNvZGUuZW5jb2RlU2VnbWVudHMoc2VncywgZWNsKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgUVIgQ29kZSByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGJpbmFyeSBkYXRhIGF0IHRoZSBnaXZlbiBlcnJvciBjb3JyZWN0aW9uIGxldmVsLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWx3YXlzIGVuY29kZXMgdXNpbmcgdGhlIGJpbmFyeSBzZWdtZW50IG1vZGUsIG5vdCBhbnkgdGV4dCBtb2RlLiBUaGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgICAvLyBieXRlcyBhbGxvd2VkIGlzIDI5NTMuIFRoZSBzbWFsbGVzdCBwb3NzaWJsZSBRUiBDb2RlIHZlcnNpb24gaXMgYXV0b21hdGljYWxseSBjaG9zZW4gZm9yIHRoZSBvdXRwdXQuXG4gICAgLy8gVGhlIEVDQyBsZXZlbCBvZiB0aGUgcmVzdWx0IG1heSBiZSBoaWdoZXIgdGhhbiB0aGUgZWNsIGFyZ3VtZW50IGlmIGl0IGNhbiBiZSBkb25lIHdpdGhvdXQgaW5jcmVhc2luZyB0aGUgdmVyc2lvbi5cbiAgICBwdWJsaWMgc3RhdGljIGVuY29kZUJpbmFyeShkYXRhOiBSZWFkb25seTxieXRlW10+LCBlY2w6IFFyQ29kZS5FY2MpOiBRckNvZGUge1xuICAgICAgY29uc3Qgc2VnOiBRclNlZ21lbnQgPSBxcmNvZGVnZW4uUXJTZWdtZW50Lm1ha2VCeXRlcyhkYXRhKTtcbiAgICAgIHJldHVybiBRckNvZGUuZW5jb2RlU2VnbWVudHMoW3NlZ10sIGVjbCk7XG4gICAgfVxuXG4gICAgLyotLSBTdGF0aWMgZmFjdG9yeSBmdW5jdGlvbnMgKG1pZCBsZXZlbCkgLS0qL1xuXG4gICAgLy8gUmV0dXJucyBhIFFSIENvZGUgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBzZWdtZW50cyB3aXRoIHRoZSBnaXZlbiBlbmNvZGluZyBwYXJhbWV0ZXJzLlxuICAgIC8vIFRoZSBzbWFsbGVzdCBwb3NzaWJsZSBRUiBDb2RlIHZlcnNpb24gd2l0aGluIHRoZSBnaXZlbiByYW5nZSBpcyBhdXRvbWF0aWNhbGx5XG4gICAgLy8gY2hvc2VuIGZvciB0aGUgb3V0cHV0LiBJZmYgYm9vc3RFY2wgaXMgdHJ1ZSwgdGhlbiB0aGUgRUNDIGxldmVsIG9mIHRoZSByZXN1bHRcbiAgICAvLyBtYXkgYmUgaGlnaGVyIHRoYW4gdGhlIGVjbCBhcmd1bWVudCBpZiBpdCBjYW4gYmUgZG9uZSB3aXRob3V0IGluY3JlYXNpbmcgdGhlXG4gICAgLy8gdmVyc2lvbi4gVGhlIG1hc2sgbnVtYmVyIGlzIGVpdGhlciBiZXR3ZWVuIDAgdG8gNyAoaW5jbHVzaXZlKSB0byBmb3JjZSB0aGF0XG4gICAgLy8gbWFzaywgb3IgLTEgdG8gYXV0b21hdGljYWxseSBjaG9vc2UgYW4gYXBwcm9wcmlhdGUgbWFzayAod2hpY2ggbWF5IGJlIHNsb3cpLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHRoZSB1c2VyIHRvIGNyZWF0ZSBhIGN1c3RvbSBzZXF1ZW5jZSBvZiBzZWdtZW50cyB0aGF0IHN3aXRjaGVzXG4gICAgLy8gYmV0d2VlbiBtb2RlcyAoc3VjaCBhcyBhbHBoYW51bWVyaWMgYW5kIGJ5dGUpIHRvIGVuY29kZSB0ZXh0IGluIGxlc3Mgc3BhY2UuXG4gICAgLy8gVGhpcyBpcyBhIG1pZC1sZXZlbCBBUEk7IHRoZSBoaWdoLWxldmVsIEFQSSBpcyBlbmNvZGVUZXh0KCkgYW5kIGVuY29kZUJpbmFyeSgpLlxuICAgIHB1YmxpYyBzdGF0aWMgZW5jb2RlU2VnbWVudHMoXG4gICAgICBzZWdzOiBSZWFkb25seTxRclNlZ21lbnRbXT4sXG4gICAgICBlY2w6IFFyQ29kZS5FY2MsXG4gICAgICBtaW5WZXJzaW9uOiBpbnQgPSAxLFxuICAgICAgbWF4VmVyc2lvbjogaW50ID0gNDAsXG4gICAgICBtYXNrOiBpbnQgPSAtMSxcbiAgICAgIGJvb3N0RWNsOiBib29sZWFuID0gdHJ1ZVxuICAgICk6IFFyQ29kZSB7XG4gICAgICBpZiAoXG4gICAgICAgICEoUXJDb2RlLk1JTl9WRVJTSU9OIDw9IG1pblZlcnNpb24gJiYgbWluVmVyc2lvbiA8PSBtYXhWZXJzaW9uICYmIG1heFZlcnNpb24gPD0gUXJDb2RlLk1BWF9WRVJTSU9OKSB8fFxuICAgICAgICBtYXNrIDwgLTEgfHxcbiAgICAgICAgbWFzayA+IDdcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcblxuICAgICAgLy8gRmluZCB0aGUgbWluaW1hbCB2ZXJzaW9uIG51bWJlciB0byB1c2VcbiAgICAgIGxldCB2ZXJzaW9uOiBpbnQ7XG4gICAgICBsZXQgZGF0YVVzZWRCaXRzOiBpbnQ7XG4gICAgICBmb3IgKHZlcnNpb24gPSBtaW5WZXJzaW9uOyA7IHZlcnNpb24rKykge1xuICAgICAgICBjb25zdCBkYXRhQ2FwYWNpdHlCaXRzOiBpbnQgPSBRckNvZGUuZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXJzaW9uLCBlY2wpICogODsgLy8gTnVtYmVyIG9mIGRhdGEgYml0cyBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgdXNlZEJpdHM6IG51bWJlciA9IFFyU2VnbWVudC5nZXRUb3RhbEJpdHMoc2VncywgdmVyc2lvbik7XG4gICAgICAgIGlmICh1c2VkQml0cyA8PSBkYXRhQ2FwYWNpdHlCaXRzKSB7XG4gICAgICAgICAgZGF0YVVzZWRCaXRzID0gdXNlZEJpdHM7XG4gICAgICAgICAgYnJlYWs7IC8vIFRoaXMgdmVyc2lvbiBudW1iZXIgaXMgZm91bmQgdG8gYmUgc3VpdGFibGVcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyc2lvbiA+PSBtYXhWZXJzaW9uKVxuICAgICAgICAgIC8vIEFsbCB2ZXJzaW9ucyBpbiB0aGUgcmFuZ2UgY291bGQgbm90IGZpdCB0aGUgZ2l2ZW4gZGF0YVxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEYXRhIHRvbyBsb25nJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEluY3JlYXNlIHRoZSBlcnJvciBjb3JyZWN0aW9uIGxldmVsIHdoaWxlIHRoZSBkYXRhIHN0aWxsIGZpdHMgaW4gdGhlIGN1cnJlbnQgdmVyc2lvbiBudW1iZXJcbiAgICAgIGZvciAoY29uc3QgbmV3RWNsIG9mIFtRckNvZGUuRWNjLk1FRElVTSwgUXJDb2RlLkVjYy5RVUFSVElMRSwgUXJDb2RlLkVjYy5ISUdIXSkge1xuICAgICAgICAvLyBGcm9tIGxvdyB0byBoaWdoXG4gICAgICAgIGlmIChib29zdEVjbCAmJiBkYXRhVXNlZEJpdHMgPD0gUXJDb2RlLmdldE51bURhdGFDb2Rld29yZHModmVyc2lvbiwgbmV3RWNsKSAqIDgpIGVjbCA9IG5ld0VjbDtcbiAgICAgIH1cblxuICAgICAgLy8gQ29uY2F0ZW5hdGUgYWxsIHNlZ21lbnRzIHRvIGNyZWF0ZSB0aGUgZGF0YSBiaXQgc3RyaW5nXG4gICAgICBsZXQgYmI6IGJpdFtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGFwcGVuZEJpdHMoc2VnLm1vZGUubW9kZUJpdHMsIDQsIGJiKTtcbiAgICAgICAgYXBwZW5kQml0cyhzZWcubnVtQ2hhcnMsIHNlZy5tb2RlLm51bUNoYXJDb3VudEJpdHModmVyc2lvbiksIGJiKTtcbiAgICAgICAgZm9yIChjb25zdCBiIG9mIHNlZy5nZXREYXRhKCkpIGJiLnB1c2goYik7XG4gICAgICB9XG4gICAgICBhc3NlcnQoYmIubGVuZ3RoID09IGRhdGFVc2VkQml0cyk7XG5cbiAgICAgIC8vIEFkZCB0ZXJtaW5hdG9yIGFuZCBwYWQgdXAgdG8gYSBieXRlIGlmIGFwcGxpY2FibGVcbiAgICAgIGNvbnN0IGRhdGFDYXBhY2l0eUJpdHM6IGludCA9IFFyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIGVjbCkgKiA4O1xuICAgICAgYXNzZXJ0KGJiLmxlbmd0aCA8PSBkYXRhQ2FwYWNpdHlCaXRzKTtcbiAgICAgIGFwcGVuZEJpdHMoMCwgTWF0aC5taW4oNCwgZGF0YUNhcGFjaXR5Qml0cyAtIGJiLmxlbmd0aCksIGJiKTtcbiAgICAgIGFwcGVuZEJpdHMoMCwgKDggLSAoYmIubGVuZ3RoICUgOCkpICUgOCwgYmIpO1xuICAgICAgYXNzZXJ0KGJiLmxlbmd0aCAlIDggPT0gMCk7XG5cbiAgICAgIC8vIFBhZCB3aXRoIGFsdGVybmF0aW5nIGJ5dGVzIHVudGlsIGRhdGEgY2FwYWNpdHkgaXMgcmVhY2hlZFxuICAgICAgZm9yIChsZXQgcGFkQnl0ZSA9IDB4ZWM7IGJiLmxlbmd0aCA8IGRhdGFDYXBhY2l0eUJpdHM7IHBhZEJ5dGUgXj0gMHhlYyBeIDB4MTEpIGFwcGVuZEJpdHMocGFkQnl0ZSwgOCwgYmIpO1xuXG4gICAgICAvLyBQYWNrIGJpdHMgaW50byBieXRlcyBpbiBiaWcgZW5kaWFuXG4gICAgICBsZXQgZGF0YUNvZGV3b3JkczogYnl0ZVtdID0gW107XG4gICAgICB3aGlsZSAoZGF0YUNvZGV3b3Jkcy5sZW5ndGggKiA4IDwgYmIubGVuZ3RoKSBkYXRhQ29kZXdvcmRzLnB1c2goMCk7XG4gICAgICBiYi5mb3JFYWNoKChiOiBiaXQsIGk6IGludCkgPT4gKGRhdGFDb2Rld29yZHNbaSA+Pj4gM10gfD0gYiA8PCAoNyAtIChpICYgNykpKSk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgUVIgQ29kZSBvYmplY3RcbiAgICAgIHJldHVybiBuZXcgUXJDb2RlKHZlcnNpb24sIGVjbCwgZGF0YUNvZGV3b3JkcywgbWFzayk7XG4gICAgfVxuXG4gICAgLyotLSBGaWVsZHMgLS0qL1xuXG4gICAgLy8gVGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhpcyBRUiBDb2RlLCBtZWFzdXJlZCBpbiBtb2R1bGVzLCBiZXR3ZWVuXG4gICAgLy8gMjEgYW5kIDE3NyAoaW5jbHVzaXZlKS4gVGhpcyBpcyBlcXVhbCB0byB2ZXJzaW9uICogNCArIDE3LlxuICAgIHB1YmxpYyByZWFkb25seSBzaXplOiBpbnQ7XG5cbiAgICAvLyBUaGUgaW5kZXggb2YgdGhlIG1hc2sgcGF0dGVybiB1c2VkIGluIHRoaXMgUVIgQ29kZSwgd2hpY2ggaXMgYmV0d2VlbiAwIGFuZCA3IChpbmNsdXNpdmUpLlxuICAgIC8vIEV2ZW4gaWYgYSBRUiBDb2RlIGlzIGNyZWF0ZWQgd2l0aCBhdXRvbWF0aWMgbWFza2luZyByZXF1ZXN0ZWQgKG1hc2sgPSAtMSksXG4gICAgLy8gdGhlIHJlc3VsdGluZyBvYmplY3Qgc3RpbGwgaGFzIGEgbWFzayB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDcuXG4gICAgcHVibGljIHJlYWRvbmx5IG1hc2s6IGludDtcblxuICAgIC8vIFRoZSBtb2R1bGVzIG9mIHRoaXMgUVIgQ29kZSAoZmFsc2UgPSBsaWdodCwgdHJ1ZSA9IGRhcmspLlxuICAgIC8vIEltbXV0YWJsZSBhZnRlciBjb25zdHJ1Y3RvciBmaW5pc2hlcy4gQWNjZXNzZWQgdGhyb3VnaCBnZXRNb2R1bGUoKS5cbiAgICBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZXM6IGJvb2xlYW5bXVtdID0gW107XG5cbiAgICAvLyBJbmRpY2F0ZXMgZnVuY3Rpb24gbW9kdWxlcyB0aGF0IGFyZSBub3Qgc3ViamVjdGVkIHRvIG1hc2tpbmcuIERpc2NhcmRlZCB3aGVuIGNvbnN0cnVjdG9yIGZpbmlzaGVzLlxuICAgIHByaXZhdGUgcmVhZG9ubHkgaXNGdW5jdGlvbjogYm9vbGVhbltdW10gPSBbXTtcblxuICAgIC8qLS0gQ29uc3RydWN0b3IgKGxvdyBsZXZlbCkgYW5kIGZpZWxkcyAtLSovXG5cbiAgICAvLyBDcmVhdGVzIGEgbmV3IFFSIENvZGUgd2l0aCB0aGUgZ2l2ZW4gdmVyc2lvbiBudW1iZXIsXG4gICAgLy8gZXJyb3IgY29ycmVjdGlvbiBsZXZlbCwgZGF0YSBjb2Rld29yZCBieXRlcywgYW5kIG1hc2sgbnVtYmVyLlxuICAgIC8vIFRoaXMgaXMgYSBsb3ctbGV2ZWwgQVBJIHRoYXQgbW9zdCB1c2VycyBzaG91bGQgbm90IHVzZSBkaXJlY3RseS5cbiAgICAvLyBBIG1pZC1sZXZlbCBBUEkgaXMgdGhlIGVuY29kZVNlZ21lbnRzKCkgZnVuY3Rpb24uXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgICAgLy8gVGhlIHZlcnNpb24gbnVtYmVyIG9mIHRoaXMgUVIgQ29kZSwgd2hpY2ggaXMgYmV0d2VlbiAxIGFuZCA0MCAoaW5jbHVzaXZlKS5cbiAgICAgIC8vIFRoaXMgZGV0ZXJtaW5lcyB0aGUgc2l6ZSBvZiB0aGlzIGJhcmNvZGUuXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgdmVyc2lvbjogaW50LFxuXG4gICAgICAvLyBUaGUgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCB1c2VkIGluIHRoaXMgUVIgQ29kZS5cbiAgICAgIHB1YmxpYyByZWFkb25seSBlcnJvckNvcnJlY3Rpb25MZXZlbDogUXJDb2RlLkVjYyxcblxuICAgICAgZGF0YUNvZGV3b3JkczogUmVhZG9ubHk8Ynl0ZVtdPixcblxuICAgICAgbXNrOiBpbnRcbiAgICApIHtcbiAgICAgIC8vIENoZWNrIHNjYWxhciBhcmd1bWVudHNcbiAgICAgIGlmICh2ZXJzaW9uIDwgUXJDb2RlLk1JTl9WRVJTSU9OIHx8IHZlcnNpb24gPiBRckNvZGUuTUFYX1ZFUlNJT04pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdWZXJzaW9uIHZhbHVlIG91dCBvZiByYW5nZScpO1xuICAgICAgaWYgKG1zayA8IC0xIHx8IG1zayA+IDcpIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXNrIHZhbHVlIG91dCBvZiByYW5nZScpO1xuICAgICAgdGhpcy5zaXplID0gdmVyc2lvbiAqIDQgKyAxNztcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBib3RoIGdyaWRzIHRvIGJlIHNpemUqc2l6ZSBhcnJheXMgb2YgQm9vbGVhbiBmYWxzZVxuICAgICAgbGV0IHJvdzogYm9vbGVhbltdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSByb3cucHVzaChmYWxzZSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgIHRoaXMubW9kdWxlcy5wdXNoKHJvdy5zbGljZSgpKTsgLy8gSW5pdGlhbGx5IGFsbCBsaWdodFxuICAgICAgICB0aGlzLmlzRnVuY3Rpb24ucHVzaChyb3cuc2xpY2UoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXB1dGUgRUNDLCBkcmF3IG1vZHVsZXNcbiAgICAgIHRoaXMuZHJhd0Z1bmN0aW9uUGF0dGVybnMoKTtcbiAgICAgIGNvbnN0IGFsbENvZGV3b3JkczogYnl0ZVtdID0gdGhpcy5hZGRFY2NBbmRJbnRlcmxlYXZlKGRhdGFDb2Rld29yZHMpO1xuICAgICAgdGhpcy5kcmF3Q29kZXdvcmRzKGFsbENvZGV3b3Jkcyk7XG5cbiAgICAgIC8vIERvIG1hc2tpbmdcbiAgICAgIGlmIChtc2sgPT0gLTEpIHtcbiAgICAgICAgLy8gQXV0b21hdGljYWxseSBjaG9vc2UgYmVzdCBtYXNrXG4gICAgICAgIGxldCBtaW5QZW5hbHR5OiBpbnQgPSAxMDAwMDAwMDAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYXBwbHlNYXNrKGkpO1xuICAgICAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMoaSk7XG4gICAgICAgICAgY29uc3QgcGVuYWx0eTogaW50ID0gdGhpcy5nZXRQZW5hbHR5U2NvcmUoKTtcbiAgICAgICAgICBpZiAocGVuYWx0eSA8IG1pblBlbmFsdHkpIHtcbiAgICAgICAgICAgIG1zayA9IGk7XG4gICAgICAgICAgICBtaW5QZW5hbHR5ID0gcGVuYWx0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hcHBseU1hc2soaSk7IC8vIFVuZG9lcyB0aGUgbWFzayBkdWUgdG8gWE9SXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzc2VydChtc2sgPj0gMCAmJiBtc2sgPD0gNyk7XG4gICAgICB0aGlzLm1hc2sgPSBtc2s7XG4gICAgICB0aGlzLmFwcGx5TWFzayhtc2spOyAvLyBBcHBseSB0aGUgZmluYWwgY2hvaWNlIG9mIG1hc2tcbiAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMobXNrKTsgLy8gT3ZlcndyaXRlIG9sZCBmb3JtYXQgYml0c1xuXG4gICAgICB0aGlzLmlzRnVuY3Rpb24gPSBbXTtcbiAgICB9XG5cbiAgICAvKi0tIEFjY2Vzc29yIG1ldGhvZHMgLS0qL1xuXG4gICAgLy8gUmV0dXJucyB0aGUgY29sb3Igb2YgdGhlIG1vZHVsZSAocGl4ZWwpIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcywgd2hpY2ggaXMgZmFsc2VcbiAgICAvLyBmb3IgbGlnaHQgb3IgdHJ1ZSBmb3IgZGFyay4gVGhlIHRvcCBsZWZ0IGNvcm5lciBoYXMgdGhlIGNvb3JkaW5hdGVzICh4PTAsIHk9MCkuXG4gICAgLy8gSWYgdGhlIGdpdmVuIGNvb3JkaW5hdGVzIGFyZSBvdXQgb2YgYm91bmRzLCB0aGVuIGZhbHNlIChsaWdodCkgaXMgcmV0dXJuZWQuXG4gICAgcHVibGljIGdldE1vZHVsZSh4OiBpbnQsIHk6IGludCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHggPj0gMCAmJiB4IDwgdGhpcy5zaXplICYmIHkgPj0gMCAmJiB5IDwgdGhpcy5zaXplICYmIHRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICB9XG5cbiAgICAvLyBNb2RpZmllZCB0byBleHBvc2UgbW9kdWxlcyBmb3IgZWFzeSBhY2Nlc3NcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlXG4gICAgcHVibGljIGdldE1vZHVsZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2R1bGVzO1xuICAgIH1cblxuICAgIC8qLS0gUHJpdmF0ZSBoZWxwZXIgbWV0aG9kcyBmb3IgY29uc3RydWN0b3I6IERyYXdpbmcgZnVuY3Rpb24gbW9kdWxlcyAtLSovXG5cbiAgICAvLyBSZWFkcyB0aGlzIG9iamVjdCdzIHZlcnNpb24gZmllbGQsIGFuZCBkcmF3cyBhbmQgbWFya3MgYWxsIGZ1bmN0aW9uIG1vZHVsZXMuXG4gICAgcHJpdmF0ZSBkcmF3RnVuY3Rpb25QYXR0ZXJucygpOiB2b2lkIHtcbiAgICAgIC8vIERyYXcgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgdGltaW5nIHBhdHRlcm5zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoNiwgaSwgaSAlIDIgPT0gMCk7XG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoaSwgNiwgaSAlIDIgPT0gMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXcgMyBmaW5kZXIgcGF0dGVybnMgKGFsbCBjb3JuZXJzIGV4Y2VwdCBib3R0b20gcmlnaHQ7IG92ZXJ3cml0ZXMgc29tZSB0aW1pbmcgbW9kdWxlcylcbiAgICAgIHRoaXMuZHJhd0ZpbmRlclBhdHRlcm4oMywgMyk7XG4gICAgICB0aGlzLmRyYXdGaW5kZXJQYXR0ZXJuKHRoaXMuc2l6ZSAtIDQsIDMpO1xuICAgICAgdGhpcy5kcmF3RmluZGVyUGF0dGVybigzLCB0aGlzLnNpemUgLSA0KTtcblxuICAgICAgLy8gRHJhdyBudW1lcm91cyBhbGlnbm1lbnQgcGF0dGVybnNcbiAgICAgIGNvbnN0IGFsaWduUGF0UG9zOiBpbnRbXSA9IHRoaXMuZ2V0QWxpZ25tZW50UGF0dGVyblBvc2l0aW9ucygpO1xuICAgICAgY29uc3QgbnVtQWxpZ246IGludCA9IGFsaWduUGF0UG9zLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQWxpZ247IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUFsaWduOyBqKyspIHtcbiAgICAgICAgICAvLyBEb24ndCBkcmF3IG9uIHRoZSB0aHJlZSBmaW5kZXIgY29ybmVyc1xuICAgICAgICAgIGlmICghKChpID09IDAgJiYgaiA9PSAwKSB8fCAoaSA9PSAwICYmIGogPT0gbnVtQWxpZ24gLSAxKSB8fCAoaSA9PSBudW1BbGlnbiAtIDEgJiYgaiA9PSAwKSkpXG4gICAgICAgICAgICB0aGlzLmRyYXdBbGlnbm1lbnRQYXR0ZXJuKGFsaWduUGF0UG9zW2ldLCBhbGlnblBhdFBvc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRHJhdyBjb25maWd1cmF0aW9uIGRhdGFcbiAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMoMCk7IC8vIER1bW15IG1hc2sgdmFsdWU7IG92ZXJ3cml0dGVuIGxhdGVyIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgdGhpcy5kcmF3VmVyc2lvbigpO1xuICAgIH1cblxuICAgIC8vIERyYXdzIHR3byBjb3BpZXMgb2YgdGhlIGZvcm1hdCBiaXRzICh3aXRoIGl0cyBvd24gZXJyb3IgY29ycmVjdGlvbiBjb2RlKVxuICAgIC8vIGJhc2VkIG9uIHRoZSBnaXZlbiBtYXNrIGFuZCB0aGlzIG9iamVjdCdzIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgZmllbGQuXG4gICAgcHJpdmF0ZSBkcmF3Rm9ybWF0Qml0cyhtYXNrOiBpbnQpOiB2b2lkIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBlcnJvciBjb3JyZWN0aW9uIGNvZGUgYW5kIHBhY2sgYml0c1xuICAgICAgY29uc3QgZGF0YTogaW50ID0gKHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwuZm9ybWF0Qml0cyA8PCAzKSB8IG1hc2s7IC8vIGVyckNvcnJMdmwgaXMgdWludDIsIG1hc2sgaXMgdWludDNcbiAgICAgIGxldCByZW06IGludCA9IGRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHJlbSA9IChyZW0gPDwgMSkgXiAoKHJlbSA+Pj4gOSkgKiAweDUzNyk7XG4gICAgICBjb25zdCBiaXRzID0gKChkYXRhIDw8IDEwKSB8IHJlbSkgXiAweDU0MTI7IC8vIHVpbnQxNVxuICAgICAgYXNzZXJ0KGJpdHMgPj4+IDE1ID09IDApO1xuXG4gICAgICAvLyBEcmF3IGZpcnN0IGNvcHlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDU7IGkrKykgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCBpLCBnZXRCaXQoYml0cywgaSkpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCA3LCBnZXRCaXQoYml0cywgNikpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCA4LCBnZXRCaXQoYml0cywgNykpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg3LCA4LCBnZXRCaXQoYml0cywgOCkpO1xuICAgICAgZm9yIChsZXQgaSA9IDk7IGkgPCAxNTsgaSsrKSB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDE0IC0gaSwgOCwgZ2V0Qml0KGJpdHMsIGkpKTtcblxuICAgICAgLy8gRHJhdyBzZWNvbmQgY29weVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUodGhpcy5zaXplIC0gMSAtIGksIDgsIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICBmb3IgKGxldCBpID0gODsgaSA8IDE1OyBpKyspIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgdGhpcy5zaXplIC0gMTUgKyBpLCBnZXRCaXQoYml0cywgaSkpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCB0aGlzLnNpemUgLSA4LCB0cnVlKTsgLy8gQWx3YXlzIGRhcmtcbiAgICB9XG5cbiAgICAvLyBEcmF3cyB0d28gY29waWVzIG9mIHRoZSB2ZXJzaW9uIGJpdHMgKHdpdGggaXRzIG93biBlcnJvciBjb3JyZWN0aW9uIGNvZGUpLFxuICAgIC8vIGJhc2VkIG9uIHRoaXMgb2JqZWN0J3MgdmVyc2lvbiBmaWVsZCwgaWZmIDcgPD0gdmVyc2lvbiA8PSA0MC5cbiAgICBwcml2YXRlIGRyYXdWZXJzaW9uKCk6IHZvaWQge1xuICAgICAgaWYgKHRoaXMudmVyc2lvbiA8IDcpIHJldHVybjtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGVycm9yIGNvcnJlY3Rpb24gY29kZSBhbmQgcGFjayBiaXRzXG4gICAgICBsZXQgcmVtOiBpbnQgPSB0aGlzLnZlcnNpb247IC8vIHZlcnNpb24gaXMgdWludDYsIGluIHRoZSByYW5nZSBbNywgNDBdXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHJlbSA9IChyZW0gPDwgMSkgXiAoKHJlbSA+Pj4gMTEpICogMHgxZjI1KTtcbiAgICAgIGNvbnN0IGJpdHM6IGludCA9ICh0aGlzLnZlcnNpb24gPDwgMTIpIHwgcmVtOyAvLyB1aW50MThcbiAgICAgIGFzc2VydChiaXRzID4+PiAxOCA9PSAwKTtcblxuICAgICAgLy8gRHJhdyB0d28gY29waWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE4OyBpKyspIHtcbiAgICAgICAgY29uc3QgY29sb3I6IGJvb2xlYW4gPSBnZXRCaXQoYml0cywgaSk7XG4gICAgICAgIGNvbnN0IGE6IGludCA9IHRoaXMuc2l6ZSAtIDExICsgKGkgJSAzKTtcbiAgICAgICAgY29uc3QgYjogaW50ID0gTWF0aC5mbG9vcihpIC8gMyk7XG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoYSwgYiwgY29sb3IpO1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKGIsIGEsIGNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcmF3cyBhIDkqOSBmaW5kZXIgcGF0dGVybiBpbmNsdWRpbmcgdGhlIGJvcmRlciBzZXBhcmF0b3IsXG4gICAgLy8gd2l0aCB0aGUgY2VudGVyIG1vZHVsZSBhdCAoeCwgeSkuIE1vZHVsZXMgY2FuIGJlIG91dCBvZiBib3VuZHMuXG4gICAgcHJpdmF0ZSBkcmF3RmluZGVyUGF0dGVybih4OiBpbnQsIHk6IGludCk6IHZvaWQge1xuICAgICAgZm9yIChsZXQgZHkgPSAtNDsgZHkgPD0gNDsgZHkrKykge1xuICAgICAgICBmb3IgKGxldCBkeCA9IC00OyBkeCA8PSA0OyBkeCsrKSB7XG4gICAgICAgICAgY29uc3QgZGlzdDogaW50ID0gTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpOyAvLyBDaGVieXNoZXYvaW5maW5pdHkgbm9ybVxuICAgICAgICAgIGNvbnN0IHh4OiBpbnQgPSB4ICsgZHg7XG4gICAgICAgICAgY29uc3QgeXk6IGludCA9IHkgKyBkeTtcbiAgICAgICAgICBpZiAoeHggPj0gMCAmJiB4eCA8IHRoaXMuc2l6ZSAmJiB5eSA+PSAwICYmIHl5IDwgdGhpcy5zaXplKVxuICAgICAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh4eCwgeXksIGRpc3QgIT0gMiAmJiBkaXN0ICE9IDQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRHJhd3MgYSA1KjUgYWxpZ25tZW50IHBhdHRlcm4sIHdpdGggdGhlIGNlbnRlciBtb2R1bGVcbiAgICAvLyBhdCAoeCwgeSkuIEFsbCBtb2R1bGVzIG11c3QgYmUgaW4gYm91bmRzLlxuICAgIHByaXZhdGUgZHJhd0FsaWdubWVudFBhdHRlcm4oeDogaW50LCB5OiBpbnQpOiB2b2lkIHtcbiAgICAgIGZvciAobGV0IGR5ID0gLTI7IGR5IDw9IDI7IGR5KyspIHtcbiAgICAgICAgZm9yIChsZXQgZHggPSAtMjsgZHggPD0gMjsgZHgrKylcbiAgICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKHggKyBkeCwgeSArIGR5LCBNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSkgIT0gMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0cyB0aGUgY29sb3Igb2YgYSBtb2R1bGUgYW5kIG1hcmtzIGl0IGFzIGEgZnVuY3Rpb24gbW9kdWxlLlxuICAgIC8vIE9ubHkgdXNlZCBieSB0aGUgY29uc3RydWN0b3IuIENvb3JkaW5hdGVzIG11c3QgYmUgaW4gYm91bmRzLlxuICAgIHByaXZhdGUgc2V0RnVuY3Rpb25Nb2R1bGUoeDogaW50LCB5OiBpbnQsIGlzRGFyazogYm9vbGVhbik6IHZvaWQge1xuICAgICAgdGhpcy5tb2R1bGVzW3ldW3hdID0gaXNEYXJrO1xuICAgICAgdGhpcy5pc0Z1bmN0aW9uW3ldW3hdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKi0tIFByaXZhdGUgaGVscGVyIG1ldGhvZHMgZm9yIGNvbnN0cnVjdG9yOiBDb2Rld29yZHMgYW5kIG1hc2tpbmcgLS0qL1xuXG4gICAgLy8gUmV0dXJucyBhIG5ldyBieXRlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGRhdGEgd2l0aCB0aGUgYXBwcm9wcmlhdGUgZXJyb3IgY29ycmVjdGlvblxuICAgIC8vIGNvZGV3b3JkcyBhcHBlbmRlZCB0byBpdCwgYmFzZWQgb24gdGhpcyBvYmplY3QncyB2ZXJzaW9uIGFuZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsLlxuICAgIHByaXZhdGUgYWRkRWNjQW5kSW50ZXJsZWF2ZShkYXRhOiBSZWFkb25seTxieXRlW10+KTogYnl0ZVtdIHtcbiAgICAgIGNvbnN0IHZlcjogaW50ID0gdGhpcy52ZXJzaW9uO1xuICAgICAgY29uc3QgZWNsOiBRckNvZGUuRWNjID0gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPSBRckNvZGUuZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXIsIGVjbCkpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwYXJhbWV0ZXIgbnVtYmVyc1xuICAgICAgY29uc3QgbnVtQmxvY2tzOiBpbnQgPSBRckNvZGUuTlVNX0VSUk9SX0NPUlJFQ1RJT05fQkxPQ0tTW2VjbC5vcmRpbmFsXVt2ZXJdO1xuICAgICAgY29uc3QgYmxvY2tFY2NMZW46IGludCA9IFFyQ29kZS5FQ0NfQ09ERVdPUkRTX1BFUl9CTE9DS1tlY2wub3JkaW5hbF1bdmVyXTtcbiAgICAgIGNvbnN0IHJhd0NvZGV3b3JkczogaW50ID0gTWF0aC5mbG9vcihRckNvZGUuZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSAvIDgpO1xuICAgICAgY29uc3QgbnVtU2hvcnRCbG9ja3M6IGludCA9IG51bUJsb2NrcyAtIChyYXdDb2Rld29yZHMgJSBudW1CbG9ja3MpO1xuICAgICAgY29uc3Qgc2hvcnRCbG9ja0xlbjogaW50ID0gTWF0aC5mbG9vcihyYXdDb2Rld29yZHMgLyBudW1CbG9ja3MpO1xuXG4gICAgICAvLyBTcGxpdCBkYXRhIGludG8gYmxvY2tzIGFuZCBhcHBlbmQgRUNDIHRvIGVhY2ggYmxvY2tcbiAgICAgIGxldCBibG9ja3M6IGJ5dGVbXVtdID0gW107XG4gICAgICBjb25zdCByc0RpdjogYnl0ZVtdID0gUXJDb2RlLnJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IoYmxvY2tFY2NMZW4pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGsgPSAwOyBpIDwgbnVtQmxvY2tzOyBpKyspIHtcbiAgICAgICAgbGV0IGRhdDogYnl0ZVtdID0gZGF0YS5zbGljZShrLCBrICsgc2hvcnRCbG9ja0xlbiAtIGJsb2NrRWNjTGVuICsgKGkgPCBudW1TaG9ydEJsb2NrcyA/IDAgOiAxKSk7XG4gICAgICAgIGsgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgZWNjOiBieXRlW10gPSBRckNvZGUucmVlZFNvbG9tb25Db21wdXRlUmVtYWluZGVyKGRhdCwgcnNEaXYpO1xuICAgICAgICBpZiAoaSA8IG51bVNob3J0QmxvY2tzKSBkYXQucHVzaCgwKTtcbiAgICAgICAgYmxvY2tzLnB1c2goZGF0LmNvbmNhdChlY2MpKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJsZWF2ZSAobm90IGNvbmNhdGVuYXRlKSB0aGUgYnl0ZXMgZnJvbSBldmVyeSBibG9jayBpbnRvIGEgc2luZ2xlIHNlcXVlbmNlXG4gICAgICBsZXQgcmVzdWx0OiBieXRlW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJsb2Nrcy5mb3JFYWNoKChibG9jaywgaikgPT4ge1xuICAgICAgICAgIC8vIFNraXAgdGhlIHBhZGRpbmcgYnl0ZSBpbiBzaG9ydCBibG9ja3NcbiAgICAgICAgICBpZiAoaSAhPSBzaG9ydEJsb2NrTGVuIC0gYmxvY2tFY2NMZW4gfHwgaiA+PSBudW1TaG9ydEJsb2NrcykgcmVzdWx0LnB1c2goYmxvY2tbaV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChyZXN1bHQubGVuZ3RoID09IHJhd0NvZGV3b3Jkcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIERyYXdzIHRoZSBnaXZlbiBzZXF1ZW5jZSBvZiA4LWJpdCBjb2Rld29yZHMgKGRhdGEgYW5kIGVycm9yIGNvcnJlY3Rpb24pIG9udG8gdGhlIGVudGlyZVxuICAgIC8vIGRhdGEgYXJlYSBvZiB0aGlzIFFSIENvZGUuIEZ1bmN0aW9uIG1vZHVsZXMgbmVlZCB0byBiZSBtYXJrZWQgb2ZmIGJlZm9yZSB0aGlzIGlzIGNhbGxlZC5cbiAgICBwcml2YXRlIGRyYXdDb2Rld29yZHMoZGF0YTogUmVhZG9ubHk8Ynl0ZVtdPik6IHZvaWQge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoICE9IE1hdGguZmxvb3IoUXJDb2RlLmdldE51bVJhd0RhdGFNb2R1bGVzKHRoaXMudmVyc2lvbikgLyA4KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIGxldCBpOiBpbnQgPSAwOyAvLyBCaXQgaW5kZXggaW50byB0aGUgZGF0YVxuICAgICAgLy8gRG8gdGhlIGZ1bm55IHppZ3phZyBzY2FuXG4gICAgICBmb3IgKGxldCByaWdodCA9IHRoaXMuc2l6ZSAtIDE7IHJpZ2h0ID49IDE7IHJpZ2h0IC09IDIpIHtcbiAgICAgICAgLy8gSW5kZXggb2YgcmlnaHQgY29sdW1uIGluIGVhY2ggY29sdW1uIHBhaXJcbiAgICAgICAgaWYgKHJpZ2h0ID09IDYpIHJpZ2h0ID0gNTtcbiAgICAgICAgZm9yIChsZXQgdmVydCA9IDA7IHZlcnQgPCB0aGlzLnNpemU7IHZlcnQrKykge1xuICAgICAgICAgIC8vIFZlcnRpY2FsIGNvdW50ZXJcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI7IGorKykge1xuICAgICAgICAgICAgY29uc3QgeDogaW50ID0gcmlnaHQgLSBqOyAvLyBBY3R1YWwgeCBjb29yZGluYXRlXG4gICAgICAgICAgICBjb25zdCB1cHdhcmQ6IGJvb2xlYW4gPSAoKHJpZ2h0ICsgMSkgJiAyKSA9PSAwO1xuICAgICAgICAgICAgY29uc3QgeTogaW50ID0gdXB3YXJkID8gdGhpcy5zaXplIC0gMSAtIHZlcnQgOiB2ZXJ0OyAvLyBBY3R1YWwgeSBjb29yZGluYXRlXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGdW5jdGlvblt5XVt4XSAmJiBpIDwgZGF0YS5sZW5ndGggKiA4KSB7XG4gICAgICAgICAgICAgIHRoaXMubW9kdWxlc1t5XVt4XSA9IGdldEJpdChkYXRhW2kgPj4+IDNdLCA3IC0gKGkgJiA3KSk7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoaXMgUVIgQ29kZSBoYXMgYW55IHJlbWFpbmRlciBiaXRzICgwIHRvIDcpLCB0aGV5IHdlcmUgYXNzaWduZWQgYXNcbiAgICAgICAgICAgIC8vIDAvZmFsc2UvbGlnaHQgYnkgdGhlIGNvbnN0cnVjdG9yIGFuZCBhcmUgbGVmdCB1bmNoYW5nZWQgYnkgdGhpcyBtZXRob2RcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzc2VydChpID09IGRhdGEubGVuZ3RoICogOCk7XG4gICAgfVxuXG4gICAgLy8gWE9ScyB0aGUgY29kZXdvcmQgbW9kdWxlcyBpbiB0aGlzIFFSIENvZGUgd2l0aCB0aGUgZ2l2ZW4gbWFzayBwYXR0ZXJuLlxuICAgIC8vIFRoZSBmdW5jdGlvbiBtb2R1bGVzIG11c3QgYmUgbWFya2VkIGFuZCB0aGUgY29kZXdvcmQgYml0cyBtdXN0IGJlIGRyYXduXG4gICAgLy8gYmVmb3JlIG1hc2tpbmcuIER1ZSB0byB0aGUgYXJpdGhtZXRpYyBvZiBYT1IsIGNhbGxpbmcgYXBwbHlNYXNrKCkgd2l0aFxuICAgIC8vIHRoZSBzYW1lIG1hc2sgdmFsdWUgYSBzZWNvbmQgdGltZSB3aWxsIHVuZG8gdGhlIG1hc2suIEEgZmluYWwgd2VsbC1mb3JtZWRcbiAgICAvLyBRUiBDb2RlIG5lZWRzIGV4YWN0bHkgb25lIChub3QgemVybywgdHdvLCBldGMuKSBtYXNrIGFwcGxpZWQuXG4gICAgcHJpdmF0ZSBhcHBseU1hc2sobWFzazogaW50KTogdm9pZCB7XG4gICAgICBpZiAobWFzayA8IDAgfHwgbWFzayA+IDcpIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXNrIHZhbHVlIG91dCBvZiByYW5nZScpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgICAgbGV0IGludmVydDogYm9vbGVhbjtcbiAgICAgICAgICBzd2l0Y2ggKG1hc2spIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKyB5KSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGludmVydCA9IHkgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBpbnZlcnQgPSB4ICUgMyA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKyB5KSAlIDMgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGludmVydCA9IChNYXRoLmZsb29yKHggLyAzKSArIE1hdGguZmxvb3IoeSAvIDIpKSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGludmVydCA9ICgoeCAqIHkpICUgMikgKyAoKHggKiB5KSAlIDMpID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBpbnZlcnQgPSAoKCh4ICogeSkgJSAyKSArICgoeCAqIHkpICUgMykpICUgMiA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKCgoeCArIHkpICUgMikgKyAoKHggKiB5KSAlIDMpKSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVhY2hhYmxlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5pc0Z1bmN0aW9uW3ldW3hdICYmIGludmVydCkgdGhpcy5tb2R1bGVzW3ldW3hdID0gIXRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIHBlbmFsdHkgc2NvcmUgYmFzZWQgb24gc3RhdGUgb2YgdGhpcyBRUiBDb2RlJ3MgY3VycmVudCBtb2R1bGVzLlxuICAgIC8vIFRoaXMgaXMgdXNlZCBieSB0aGUgYXV0b21hdGljIG1hc2sgY2hvaWNlIGFsZ29yaXRobSB0byBmaW5kIHRoZSBtYXNrIHBhdHRlcm4gdGhhdCB5aWVsZHMgdGhlIGxvd2VzdCBzY29yZS5cbiAgICBwcml2YXRlIGdldFBlbmFsdHlTY29yZSgpOiBpbnQge1xuICAgICAgbGV0IHJlc3VsdDogaW50ID0gMDtcblxuICAgICAgLy8gQWRqYWNlbnQgbW9kdWxlcyBpbiByb3cgaGF2aW5nIHNhbWUgY29sb3IsIGFuZCBmaW5kZXItbGlrZSBwYXR0ZXJuc1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICBsZXQgcnVuQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJ1blggPSAwO1xuICAgICAgICBsZXQgcnVuSGlzdG9yeSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemU7IHgrKykge1xuICAgICAgICAgIGlmICh0aGlzLm1vZHVsZXNbeV1beF0gPT0gcnVuQ29sb3IpIHtcbiAgICAgICAgICAgIHJ1blgrKztcbiAgICAgICAgICAgIGlmIChydW5YID09IDUpIHJlc3VsdCArPSBRckNvZGUuUEVOQUxUWV9OMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1blggPiA1KSByZXN1bHQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShydW5YLCBydW5IaXN0b3J5KTtcbiAgICAgICAgICAgIGlmICghcnVuQ29sb3IpIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpICogUXJDb2RlLlBFTkFMVFlfTjM7XG4gICAgICAgICAgICBydW5Db2xvciA9IHRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICAgICAgICAgIHJ1blggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5VGVybWluYXRlQW5kQ291bnQocnVuQ29sb3IsIHJ1blgsIHJ1bkhpc3RvcnkpICogUXJDb2RlLlBFTkFMVFlfTjM7XG4gICAgICB9XG4gICAgICAvLyBBZGphY2VudCBtb2R1bGVzIGluIGNvbHVtbiBoYXZpbmcgc2FtZSBjb2xvciwgYW5kIGZpbmRlci1saWtlIHBhdHRlcm5zXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgIGxldCBydW5Db2xvciA9IGZhbHNlO1xuICAgICAgICBsZXQgcnVuWSA9IDA7XG4gICAgICAgIGxldCBydW5IaXN0b3J5ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZTsgeSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kdWxlc1t5XVt4XSA9PSBydW5Db2xvcikge1xuICAgICAgICAgICAgcnVuWSsrO1xuICAgICAgICAgICAgaWYgKHJ1blkgPT0gNSkgcmVzdWx0ICs9IFFyQ29kZS5QRU5BTFRZX04xO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVuWSA+IDUpIHJlc3VsdCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KHJ1blksIHJ1bkhpc3RvcnkpO1xuICAgICAgICAgICAgaWYgKCFydW5Db2xvcikgcmVzdWx0ICs9IHRoaXMuZmluZGVyUGVuYWx0eUNvdW50UGF0dGVybnMocnVuSGlzdG9yeSkgKiBRckNvZGUuUEVOQUxUWV9OMztcbiAgICAgICAgICAgIHJ1bkNvbG9yID0gdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICAgICAgcnVuWSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChydW5Db2xvciwgcnVuWSwgcnVuSGlzdG9yeSkgKiBRckNvZGUuUEVOQUxUWV9OMztcbiAgICAgIH1cblxuICAgICAgLy8gMioyIGJsb2NrcyBvZiBtb2R1bGVzIGhhdmluZyBzYW1lIGNvbG9yXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZSAtIDE7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZSAtIDE7IHgrKykge1xuICAgICAgICAgIGNvbnN0IGNvbG9yOiBib29sZWFuID0gdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICAgIGlmIChjb2xvciA9PSB0aGlzLm1vZHVsZXNbeV1beCArIDFdICYmIGNvbG9yID09IHRoaXMubW9kdWxlc1t5ICsgMV1beF0gJiYgY29sb3IgPT0gdGhpcy5tb2R1bGVzW3kgKyAxXVt4ICsgMV0pXG4gICAgICAgICAgICByZXN1bHQgKz0gUXJDb2RlLlBFTkFMVFlfTjI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQmFsYW5jZSBvZiBkYXJrIGFuZCBsaWdodCBtb2R1bGVzXG4gICAgICBsZXQgZGFyazogaW50ID0gMDtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRoaXMubW9kdWxlcykgZGFyayA9IHJvdy5yZWR1Y2UoKHN1bSwgY29sb3IpID0+IHN1bSArIChjb2xvciA/IDEgOiAwKSwgZGFyayk7XG4gICAgICBjb25zdCB0b3RhbDogaW50ID0gdGhpcy5zaXplICogdGhpcy5zaXplOyAvLyBOb3RlIHRoYXQgc2l6ZSBpcyBvZGQsIHNvIGRhcmsvdG90YWwgIT0gMS8yXG4gICAgICAvLyBDb21wdXRlIHRoZSBzbWFsbGVzdCBpbnRlZ2VyIGsgPj0gMCBzdWNoIHRoYXQgKDQ1LTVrKSUgPD0gZGFyay90b3RhbCA8PSAoNTUrNWspJVxuICAgICAgY29uc3QgazogaW50ID0gTWF0aC5jZWlsKE1hdGguYWJzKGRhcmsgKiAyMCAtIHRvdGFsICogMTApIC8gdG90YWwpIC0gMTtcbiAgICAgIGFzc2VydChrID49IDAgJiYgayA8PSA5KTtcbiAgICAgIHJlc3VsdCArPSBrICogUXJDb2RlLlBFTkFMVFlfTjQ7XG4gICAgICBhc3NlcnQocmVzdWx0ID49IDAgJiYgcmVzdWx0IDw9IDI1Njg4ODgpOyAvLyBOb24tdGlnaHQgdXBwZXIgYm91bmQgYmFzZWQgb24gZGVmYXVsdCB2YWx1ZXMgb2YgUEVOQUxUWV9OMSwgLi4uLCBONFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tIFByaXZhdGUgaGVscGVyIGZ1bmN0aW9ucyAtLSovXG5cbiAgICAvLyBSZXR1cm5zIGFuIGFzY2VuZGluZyBsaXN0IG9mIHBvc2l0aW9ucyBvZiBhbGlnbm1lbnQgcGF0dGVybnMgZm9yIHRoaXMgdmVyc2lvbiBudW1iZXIuXG4gICAgLy8gRWFjaCBwb3NpdGlvbiBpcyBpbiB0aGUgcmFuZ2UgWzAsMTc3KSwgYW5kIGFyZSB1c2VkIG9uIGJvdGggdGhlIHggYW5kIHkgYXhlcy5cbiAgICAvLyBUaGlzIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIGxvb2t1cCB0YWJsZSBvZiA0MCB2YXJpYWJsZS1sZW5ndGggbGlzdHMgb2YgaW50ZWdlcnMuXG4gICAgcHJpdmF0ZSBnZXRBbGlnbm1lbnRQYXR0ZXJuUG9zaXRpb25zKCk6IGludFtdIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPT0gMSkgcmV0dXJuIFtdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG51bUFsaWduOiBpbnQgPSBNYXRoLmZsb29yKHRoaXMudmVyc2lvbiAvIDcpICsgMjtcbiAgICAgICAgY29uc3Qgc3RlcDogaW50ID0gdGhpcy52ZXJzaW9uID09IDMyID8gMjYgOiBNYXRoLmNlaWwoKHRoaXMudmVyc2lvbiAqIDQgKyA0KSAvIChudW1BbGlnbiAqIDIgLSAyKSkgKiAyO1xuICAgICAgICBsZXQgcmVzdWx0OiBpbnRbXSA9IFs2XTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGhpcy5zaXplIC0gNzsgcmVzdWx0Lmxlbmd0aCA8IG51bUFsaWduOyBwb3MgLT0gc3RlcCkgcmVzdWx0LnNwbGljZSgxLCAwLCBwb3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXRhIGJpdHMgdGhhdCBjYW4gYmUgc3RvcmVkIGluIGEgUVIgQ29kZSBvZiB0aGUgZ2l2ZW4gdmVyc2lvbiBudW1iZXIsIGFmdGVyXG4gICAgLy8gYWxsIGZ1bmN0aW9uIG1vZHVsZXMgYXJlIGV4Y2x1ZGVkLiBUaGlzIGluY2x1ZGVzIHJlbWFpbmRlciBiaXRzLCBzbyBpdCBtaWdodCBub3QgYmUgYSBtdWx0aXBsZSBvZiA4LlxuICAgIC8vIFRoZSByZXN1bHQgaXMgaW4gdGhlIHJhbmdlIFsyMDgsIDI5NjQ4XS4gVGhpcyBjb3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBhIDQwLWVudHJ5IGxvb2t1cCB0YWJsZS5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXROdW1SYXdEYXRhTW9kdWxlcyh2ZXI6IGludCk6IGludCB7XG4gICAgICBpZiAodmVyIDwgUXJDb2RlLk1JTl9WRVJTSU9OIHx8IHZlciA+IFFyQ29kZS5NQVhfVkVSU0lPTikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1ZlcnNpb24gbnVtYmVyIG91dCBvZiByYW5nZScpO1xuICAgICAgbGV0IHJlc3VsdDogaW50ID0gKDE2ICogdmVyICsgMTI4KSAqIHZlciArIDY0O1xuICAgICAgaWYgKHZlciA+PSAyKSB7XG4gICAgICAgIGNvbnN0IG51bUFsaWduOiBpbnQgPSBNYXRoLmZsb29yKHZlciAvIDcpICsgMjtcbiAgICAgICAgcmVzdWx0IC09ICgyNSAqIG51bUFsaWduIC0gMTApICogbnVtQWxpZ24gLSA1NTtcbiAgICAgICAgaWYgKHZlciA+PSA3KSByZXN1bHQgLT0gMzY7XG4gICAgICB9XG4gICAgICBhc3NlcnQocmVzdWx0ID49IDIwOCAmJiByZXN1bHQgPD0gMjk2NDgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgOC1iaXQgZGF0YSAoaS5lLiBub3QgZXJyb3IgY29ycmVjdGlvbikgY29kZXdvcmRzIGNvbnRhaW5lZCBpbiBhbnlcbiAgICAvLyBRUiBDb2RlIG9mIHRoZSBnaXZlbiB2ZXJzaW9uIG51bWJlciBhbmQgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCwgd2l0aCByZW1haW5kZXIgYml0cyBkaXNjYXJkZWQuXG4gICAgLy8gVGhpcyBzdGF0ZWxlc3MgcHVyZSBmdW5jdGlvbiBjb3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBhICg0MCo0KS1jZWxsIGxvb2t1cCB0YWJsZS5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXROdW1EYXRhQ29kZXdvcmRzKHZlcjogaW50LCBlY2w6IFFyQ29kZS5FY2MpOiBpbnQge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgTWF0aC5mbG9vcihRckNvZGUuZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSAvIDgpIC1cbiAgICAgICAgUXJDb2RlLkVDQ19DT0RFV09SRFNfUEVSX0JMT0NLW2VjbC5vcmRpbmFsXVt2ZXJdICogUXJDb2RlLk5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLU1tlY2wub3JkaW5hbF1bdmVyXVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgUmVlZC1Tb2xvbW9uIEVDQyBnZW5lcmF0b3IgcG9seW5vbWlhbCBmb3IgdGhlIGdpdmVuIGRlZ3JlZS4gVGhpcyBjb3VsZCBiZVxuICAgIC8vIGltcGxlbWVudGVkIGFzIGEgbG9va3VwIHRhYmxlIG92ZXIgYWxsIHBvc3NpYmxlIHBhcmFtZXRlciB2YWx1ZXMsIGluc3RlYWQgb2YgYXMgYW4gYWxnb3JpdGhtLlxuICAgIHByaXZhdGUgc3RhdGljIHJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IoZGVncmVlOiBpbnQpOiBieXRlW10ge1xuICAgICAgaWYgKGRlZ3JlZSA8IDEgfHwgZGVncmVlID4gMjU1KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGVncmVlIG91dCBvZiByYW5nZScpO1xuICAgICAgLy8gUG9seW5vbWlhbCBjb2VmZmljaWVudHMgYXJlIHN0b3JlZCBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IHBvd2VyLCBleGNsdWRpbmcgdGhlIGxlYWRpbmcgdGVybSB3aGljaCBpcyBhbHdheXMgMS5cbiAgICAgIC8vIEZvciBleGFtcGxlIHRoZSBwb2x5bm9taWFsIHheMyArIDI1NXheMiArIDh4ICsgOTMgaXMgc3RvcmVkIGFzIHRoZSB1aW50OCBhcnJheSBbMjU1LCA4LCA5M10uXG4gICAgICBsZXQgcmVzdWx0OiBieXRlW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVncmVlIC0gMTsgaSsrKSByZXN1bHQucHVzaCgwKTtcbiAgICAgIHJlc3VsdC5wdXNoKDEpOyAvLyBTdGFydCBvZmYgd2l0aCB0aGUgbW9ub21pYWwgeF4wXG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHByb2R1Y3QgcG9seW5vbWlhbCAoeCAtIHJeMCkgKiAoeCAtIHJeMSkgKiAoeCAtIHJeMikgKiAuLi4gKiAoeCAtIHJee2RlZ3JlZS0xfSksXG4gICAgICAvLyBhbmQgZHJvcCB0aGUgaGlnaGVzdCBtb25vbWlhbCB0ZXJtIHdoaWNoIGlzIGFsd2F5cyAxeF5kZWdyZWUuXG4gICAgICAvLyBOb3RlIHRoYXQgciA9IDB4MDIsIHdoaWNoIGlzIGEgZ2VuZXJhdG9yIGVsZW1lbnQgb2YgdGhpcyBmaWVsZCBHRigyXjgvMHgxMUQpLlxuICAgICAgbGV0IHJvb3QgPSAxO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWdyZWU7IGkrKykge1xuICAgICAgICAvLyBNdWx0aXBseSB0aGUgY3VycmVudCBwcm9kdWN0IGJ5ICh4IC0gcl5pKVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHJlc3VsdFtqXSA9IFFyQ29kZS5yZWVkU29sb21vbk11bHRpcGx5KHJlc3VsdFtqXSwgcm9vdCk7XG4gICAgICAgICAgaWYgKGogKyAxIDwgcmVzdWx0Lmxlbmd0aCkgcmVzdWx0W2pdIF49IHJlc3VsdFtqICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IFFyQ29kZS5yZWVkU29sb21vbk11bHRpcGx5KHJvb3QsIDB4MDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBSZWVkLVNvbG9tb24gZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZCBmb3IgdGhlIGdpdmVuIGRhdGEgYW5kIGRpdmlzb3IgcG9seW5vbWlhbHMuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVlZFNvbG9tb25Db21wdXRlUmVtYWluZGVyKGRhdGE6IFJlYWRvbmx5PGJ5dGVbXT4sIGRpdmlzb3I6IFJlYWRvbmx5PGJ5dGVbXT4pOiBieXRlW10ge1xuICAgICAgbGV0IHJlc3VsdDogYnl0ZVtdID0gZGl2aXNvci5tYXAoXyA9PiAwKTtcbiAgICAgIGZvciAoY29uc3QgYiBvZiBkYXRhKSB7XG4gICAgICAgIC8vIFBvbHlub21pYWwgZGl2aXNpb25cbiAgICAgICAgY29uc3QgZmFjdG9yOiBieXRlID0gYiBeIChyZXN1bHQuc2hpZnQoKSBhcyBieXRlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICAgIGRpdmlzb3IuZm9yRWFjaCgoY29lZiwgaSkgPT4gKHJlc3VsdFtpXSBePSBRckNvZGUucmVlZFNvbG9tb25NdWx0aXBseShjb2VmLCBmYWN0b3IpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhlIHR3byBnaXZlbiBmaWVsZCBlbGVtZW50cyBtb2R1bG8gR0YoMl44LzB4MTFEKS4gVGhlIGFyZ3VtZW50cyBhbmQgcmVzdWx0XG4gICAgLy8gYXJlIHVuc2lnbmVkIDgtYml0IGludGVnZXJzLiBUaGlzIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIGEgbG9va3VwIHRhYmxlIG9mIDI1NioyNTYgZW50cmllcyBvZiB1aW50OC5cbiAgICBwcml2YXRlIHN0YXRpYyByZWVkU29sb21vbk11bHRpcGx5KHg6IGJ5dGUsIHk6IGJ5dGUpOiBieXRlIHtcbiAgICAgIGlmICh4ID4+PiA4ICE9IDAgfHwgeSA+Pj4gOCAhPSAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnl0ZSBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgIC8vIFJ1c3NpYW4gcGVhc2FudCBtdWx0aXBsaWNhdGlvblxuICAgICAgbGV0IHo6IGludCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gNzsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgeiA9ICh6IDw8IDEpIF4gKCh6ID4+PiA3KSAqIDB4MTFkKTtcbiAgICAgICAgeiBePSAoKHkgPj4+IGkpICYgMSkgKiB4O1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHogPj4+IDggPT0gMCk7XG4gICAgICByZXR1cm4geiBhcyBieXRlO1xuICAgIH1cblxuICAgIC8vIENhbiBvbmx5IGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBhIGxpZ2h0IHJ1biBpcyBhZGRlZCwgYW5kXG4gICAgLy8gcmV0dXJucyBlaXRoZXIgMCwgMSwgb3IgMi4gQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldFBlbmFsdHlTY29yZSgpLlxuICAgIHByaXZhdGUgZmluZGVyUGVuYWx0eUNvdW50UGF0dGVybnMocnVuSGlzdG9yeTogUmVhZG9ubHk8aW50W10+KTogaW50IHtcbiAgICAgIGNvbnN0IG46IGludCA9IHJ1bkhpc3RvcnlbMV07XG4gICAgICBhc3NlcnQobiA8PSB0aGlzLnNpemUgKiAzKTtcbiAgICAgIGNvbnN0IGNvcmU6IGJvb2xlYW4gPVxuICAgICAgICBuID4gMCAmJiBydW5IaXN0b3J5WzJdID09IG4gJiYgcnVuSGlzdG9yeVszXSA9PSBuICogMyAmJiBydW5IaXN0b3J5WzRdID09IG4gJiYgcnVuSGlzdG9yeVs1XSA9PSBuO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGNvcmUgJiYgcnVuSGlzdG9yeVswXSA+PSBuICogNCAmJiBydW5IaXN0b3J5WzZdID49IG4gPyAxIDogMCkgK1xuICAgICAgICAoY29yZSAmJiBydW5IaXN0b3J5WzZdID49IG4gKiA0ICYmIHJ1bkhpc3RvcnlbMF0gPj0gbiA/IDEgOiAwKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBNdXN0IGJlIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGEgbGluZSAocm93IG9yIGNvbHVtbikgb2YgbW9kdWxlcy4gQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldFBlbmFsdHlTY29yZSgpLlxuICAgIHByaXZhdGUgZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KGN1cnJlbnRSdW5Db2xvcjogYm9vbGVhbiwgY3VycmVudFJ1bkxlbmd0aDogaW50LCBydW5IaXN0b3J5OiBpbnRbXSk6IGludCB7XG4gICAgICBpZiAoY3VycmVudFJ1bkNvbG9yKSB7XG4gICAgICAgIC8vIFRlcm1pbmF0ZSBkYXJrIHJ1blxuICAgICAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KGN1cnJlbnRSdW5MZW5ndGgsIHJ1bkhpc3RvcnkpO1xuICAgICAgICBjdXJyZW50UnVuTGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSdW5MZW5ndGggKz0gdGhpcy5zaXplOyAvLyBBZGQgbGlnaHQgYm9yZGVyIHRvIGZpbmFsIHJ1blxuICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpO1xuICAgIH1cblxuICAgIC8vIFB1c2hlcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGZyb250IGFuZCBkcm9wcyB0aGUgbGFzdCB2YWx1ZS4gQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldFBlbmFsdHlTY29yZSgpLlxuICAgIHByaXZhdGUgZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkoY3VycmVudFJ1bkxlbmd0aDogaW50LCBydW5IaXN0b3J5OiBpbnRbXSk6IHZvaWQge1xuICAgICAgaWYgKHJ1bkhpc3RvcnlbMF0gPT0gMCkgY3VycmVudFJ1bkxlbmd0aCArPSB0aGlzLnNpemU7IC8vIEFkZCBsaWdodCBib3JkZXIgdG8gaW5pdGlhbCBydW5cbiAgICAgIHJ1bkhpc3RvcnkucG9wKCk7XG4gICAgICBydW5IaXN0b3J5LnVuc2hpZnQoY3VycmVudFJ1bkxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyotLSBDb25zdGFudHMgYW5kIHRhYmxlcyAtLSovXG5cbiAgICAvLyBUaGUgbWluaW11bSB2ZXJzaW9uIG51bWJlciBzdXBwb3J0ZWQgaW4gdGhlIFFSIENvZGUgTW9kZWwgMiBzdGFuZGFyZC5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE1JTl9WRVJTSU9OOiBpbnQgPSAxO1xuICAgIC8vIFRoZSBtYXhpbXVtIHZlcnNpb24gbnVtYmVyIHN1cHBvcnRlZCBpbiB0aGUgUVIgQ29kZSBNb2RlbCAyIHN0YW5kYXJkLlxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTUFYX1ZFUlNJT046IGludCA9IDQwO1xuXG4gICAgLy8gRm9yIHVzZSBpbiBnZXRQZW5hbHR5U2NvcmUoKSwgd2hlbiBldmFsdWF0aW5nIHdoaWNoIG1hc2sgaXMgYmVzdC5cbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBQRU5BTFRZX04xOiBpbnQgPSAzO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFBFTkFMVFlfTjI6IGludCA9IDM7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgUEVOQUxUWV9OMzogaW50ID0gNDA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgUEVOQUxUWV9ONDogaW50ID0gMTA7XG5cbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFQ0NfQ09ERVdPUkRTX1BFUl9CTE9DSzogaW50W11bXSA9IFtcbiAgICAgIC8vIFZlcnNpb246IChub3RlIHRoYXQgaW5kZXggMCBpcyBmb3IgcGFkZGluZywgYW5kIGlzIHNldCB0byBhbiBpbGxlZ2FsIHZhbHVlKVxuICAgICAgLy8wLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MCAgICBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gICAgICBbXG4gICAgICAgIC0xLCA3LCAxMCwgMTUsIDIwLCAyNiwgMTgsIDIwLCAyNCwgMzAsIDE4LCAyMCwgMjQsIDI2LCAzMCwgMjIsIDI0LCAyOCwgMzAsIDI4LCAyOCwgMjgsIDI4LCAzMCwgMzAsIDI2LCAyOCwgMzAsXG4gICAgICAgIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXG4gICAgICBdLCAvLyBMb3dcbiAgICAgIFtcbiAgICAgICAgLTEsIDEwLCAxNiwgMjYsIDE4LCAyNCwgMTYsIDE4LCAyMiwgMjIsIDI2LCAzMCwgMjIsIDIyLCAyNCwgMjQsIDI4LCAyOCwgMjYsIDI2LCAyNiwgMjYsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsXG4gICAgICAgIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4XG4gICAgICBdLCAvLyBNZWRpdW1cbiAgICAgIFtcbiAgICAgICAgLTEsIDEzLCAyMiwgMTgsIDI2LCAxOCwgMjQsIDE4LCAyMiwgMjAsIDI0LCAyOCwgMjYsIDI0LCAyMCwgMzAsIDI0LCAyOCwgMjgsIDI2LCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAyOCwgMzAsXG4gICAgICAgIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXG4gICAgICBdLCAvLyBRdWFydGlsZVxuICAgICAgW1xuICAgICAgICAtMSwgMTcsIDI4LCAyMiwgMTYsIDIyLCAyOCwgMjYsIDI2LCAyNCwgMjgsIDI0LCAyOCwgMjIsIDI0LCAyNCwgMzAsIDI4LCAyOCwgMjYsIDI4LCAzMCwgMjQsIDMwLCAzMCwgMzAsIDMwLCAzMCxcbiAgICAgICAgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzBcbiAgICAgIF0gLy8gSGlnaFxuICAgIF07XG5cbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBOVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1M6IGludFtdW10gPSBbXG4gICAgICAvLyBWZXJzaW9uOiAobm90ZSB0aGF0IGluZGV4IDAgaXMgZm9yIHBhZGRpbmcsIGFuZCBpcyBzZXQgdG8gYW4gaWxsZWdhbCB2YWx1ZSlcbiAgICAgIC8vMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MCAgICBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gICAgICBbXG4gICAgICAgIC0xLCAxLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCA0LCA0LCA0LCA0LCA0LCA2LCA2LCA2LCA2LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTIsIDEyLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCxcbiAgICAgICAgMTksIDE5LCAyMCwgMjEsIDIyLCAyNCwgMjVcbiAgICAgIF0sIC8vIExvd1xuICAgICAgW1xuICAgICAgICAtMSwgMSwgMSwgMSwgMiwgMiwgNCwgNCwgNCwgNSwgNSwgNSwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTMsIDE0LCAxNiwgMTcsIDE3LCAxOCwgMjAsIDIxLCAyMywgMjUsIDI2LCAyOCwgMjksXG4gICAgICAgIDMxLCAzMywgMzUsIDM3LCAzOCwgNDAsIDQzLCA0NSwgNDcsIDQ5XG4gICAgICBdLCAvLyBNZWRpdW1cbiAgICAgIFtcbiAgICAgICAgLTEsIDEsIDEsIDIsIDIsIDQsIDQsIDYsIDYsIDgsIDgsIDgsIDEwLCAxMiwgMTYsIDEyLCAxNywgMTYsIDE4LCAyMSwgMjAsIDIzLCAyMywgMjUsIDI3LCAyOSwgMzQsIDM0LCAzNSwgMzgsIDQwLFxuICAgICAgICA0MywgNDUsIDQ4LCA1MSwgNTMsIDU2LCA1OSwgNjIsIDY1LCA2OFxuICAgICAgXSwgLy8gUXVhcnRpbGVcbiAgICAgIFtcbiAgICAgICAgLTEsIDEsIDEsIDIsIDQsIDQsIDQsIDUsIDYsIDgsIDgsIDExLCAxMSwgMTYsIDE2LCAxOCwgMTYsIDE5LCAyMSwgMjUsIDI1LCAyNSwgMzQsIDMwLCAzMiwgMzUsIDM3LCA0MCwgNDIsIDQ1LFxuICAgICAgICA0OCwgNTEsIDU0LCA1NywgNjAsIDYzLCA2NiwgNzAsIDc0LCA3NywgODFcbiAgICAgIF0gLy8gSGlnaFxuICAgIF07XG4gIH1cblxuICAvLyBBcHBlbmRzIHRoZSBnaXZlbiBudW1iZXIgb2YgbG93LW9yZGVyIGJpdHMgb2YgdGhlIGdpdmVuIHZhbHVlXG4gIC8vIHRvIHRoZSBnaXZlbiBidWZmZXIuIFJlcXVpcmVzIDAgPD0gbGVuIDw9IDMxIGFuZCAwIDw9IHZhbCA8IDJebGVuLlxuICBmdW5jdGlvbiBhcHBlbmRCaXRzKHZhbDogaW50LCBsZW46IGludCwgYmI6IGJpdFtdKTogdm9pZCB7XG4gICAgaWYgKGxlbiA8IDAgfHwgbGVuID4gMzEgfHwgdmFsID4+PiBsZW4gIT0gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1ZhbHVlIG91dCBvZiByYW5nZScpO1xuICAgIGZvciAoXG4gICAgICBsZXQgaSA9IGxlbiAtIDE7XG4gICAgICBpID49IDA7XG4gICAgICBpLS0gLy8gQXBwZW5kIGJpdCBieSBiaXRcbiAgICApXG4gICAgICBiYi5wdXNoKCh2YWwgPj4+IGkpICYgMSk7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBpJ3RoIGJpdCBvZiB4IGlzIHNldCB0byAxLlxuICBmdW5jdGlvbiBnZXRCaXQoeDogaW50LCBpOiBpbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKCh4ID4+PiBpKSAmIDEpICE9IDA7XG4gIH1cblxuICAvLyBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBnaXZlbiBjb25kaXRpb24gaXMgZmFsc2UuXG4gIGZ1bmN0aW9uIGFzc2VydChjb25kOiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKCFjb25kKSB0aHJvdyBuZXcgRXJyb3IoJ0Fzc2VydGlvbiBlcnJvcicpO1xuICB9XG5cbiAgLyotLS0tIERhdGEgc2VnbWVudCBjbGFzcyAtLS0tKi9cblxuICAvKlxuICAgKiBBIHNlZ21lbnQgb2YgY2hhcmFjdGVyL2JpbmFyeS9jb250cm9sIGRhdGEgaW4gYSBRUiBDb2RlIHN5bWJvbC5cbiAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGltbXV0YWJsZS5cbiAgICogVGhlIG1pZC1sZXZlbCB3YXkgdG8gY3JlYXRlIGEgc2VnbWVudCBpcyB0byB0YWtlIHRoZSBwYXlsb2FkIGRhdGFcbiAgICogYW5kIGNhbGwgYSBzdGF0aWMgZmFjdG9yeSBmdW5jdGlvbiBzdWNoIGFzIFFyU2VnbWVudC5tYWtlTnVtZXJpYygpLlxuICAgKiBUaGUgbG93LWxldmVsIHdheSB0byBjcmVhdGUgYSBzZWdtZW50IGlzIHRvIGN1c3RvbS1tYWtlIHRoZSBiaXQgYnVmZmVyXG4gICAqIGFuZCBjYWxsIHRoZSBRclNlZ21lbnQoKSBjb25zdHJ1Y3RvciB3aXRoIGFwcHJvcHJpYXRlIHZhbHVlcy5cbiAgICogVGhpcyBzZWdtZW50IGNsYXNzIGltcG9zZXMgbm8gbGVuZ3RoIHJlc3RyaWN0aW9ucywgYnV0IFFSIENvZGVzIGhhdmUgcmVzdHJpY3Rpb25zLlxuICAgKiBFdmVuIGluIHRoZSBtb3N0IGZhdm9yYWJsZSBjb25kaXRpb25zLCBhIFFSIENvZGUgY2FuIG9ubHkgaG9sZCA3MDg5IGNoYXJhY3RlcnMgb2YgZGF0YS5cbiAgICogQW55IHNlZ21lbnQgbG9uZ2VyIHRoYW4gdGhpcyBpcyBtZWFuaW5nbGVzcyBmb3IgdGhlIHB1cnBvc2Ugb2YgZ2VuZXJhdGluZyBRUiBDb2Rlcy5cbiAgICovXG4gIGV4cG9ydCBjbGFzcyBRclNlZ21lbnQge1xuICAgIC8qLS0gU3RhdGljIGZhY3RvcnkgZnVuY3Rpb25zIChtaWQgbGV2ZWwpIC0tKi9cblxuICAgIC8vIFJldHVybnMgYSBzZWdtZW50IHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gYmluYXJ5IGRhdGEgZW5jb2RlZCBpblxuICAgIC8vIGJ5dGUgbW9kZS4gQWxsIGlucHV0IGJ5dGUgYXJyYXlzIGFyZSBhY2NlcHRhYmxlLiBBbnkgdGV4dCBzdHJpbmdcbiAgICAvLyBjYW4gYmUgY29udmVydGVkIHRvIFVURi04IGJ5dGVzIGFuZCBlbmNvZGVkIGFzIGEgYnl0ZSBtb2RlIHNlZ21lbnQuXG4gICAgcHVibGljIHN0YXRpYyBtYWtlQnl0ZXMoZGF0YTogUmVhZG9ubHk8Ynl0ZVtdPik6IFFyU2VnbWVudCB7XG4gICAgICBsZXQgYmI6IGJpdFtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGIgb2YgZGF0YSkgYXBwZW5kQml0cyhiLCA4LCBiYik7XG4gICAgICByZXR1cm4gbmV3IFFyU2VnbWVudChRclNlZ21lbnQuTW9kZS5CWVRFLCBkYXRhLmxlbmd0aCwgYmIpO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBzZWdtZW50IHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGRlY2ltYWwgZGlnaXRzIGVuY29kZWQgaW4gbnVtZXJpYyBtb2RlLlxuICAgIHB1YmxpYyBzdGF0aWMgbWFrZU51bWVyaWMoZGlnaXRzOiBzdHJpbmcpOiBRclNlZ21lbnQge1xuICAgICAgaWYgKCFRclNlZ21lbnQuaXNOdW1lcmljKGRpZ2l0cykpIHRocm93IG5ldyBSYW5nZUVycm9yKCdTdHJpbmcgY29udGFpbnMgbm9uLW51bWVyaWMgY2hhcmFjdGVycycpO1xuICAgICAgbGV0IGJiOiBiaXRbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWdpdHMubGVuZ3RoOyApIHtcbiAgICAgICAgLy8gQ29uc3VtZSB1cCB0byAzIGRpZ2l0cyBwZXIgaXRlcmF0aW9uXG4gICAgICAgIGNvbnN0IG46IGludCA9IE1hdGgubWluKGRpZ2l0cy5sZW5ndGggLSBpLCAzKTtcbiAgICAgICAgYXBwZW5kQml0cyhwYXJzZUludChkaWdpdHMuc3Vic3RyaW5nKGksIGkgKyBuKSwgMTApLCBuICogMyArIDEsIGJiKTtcbiAgICAgICAgaSArPSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBRclNlZ21lbnQoUXJTZWdtZW50Lk1vZGUuTlVNRVJJQywgZGlnaXRzLmxlbmd0aCwgYmIpO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBzZWdtZW50IHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdGV4dCBzdHJpbmcgZW5jb2RlZCBpbiBhbHBoYW51bWVyaWMgbW9kZS5cbiAgICAvLyBUaGUgY2hhcmFjdGVycyBhbGxvd2VkIGFyZTogMCB0byA5LCBBIHRvIFogKHVwcGVyY2FzZSBvbmx5KSwgc3BhY2UsXG4gICAgLy8gZG9sbGFyLCBwZXJjZW50LCBhc3RlcmlzaywgcGx1cywgaHlwaGVuLCBwZXJpb2QsIHNsYXNoLCBjb2xvbi5cbiAgICBwdWJsaWMgc3RhdGljIG1ha2VBbHBoYW51bWVyaWModGV4dDogc3RyaW5nKTogUXJTZWdtZW50IHtcbiAgICAgIGlmICghUXJTZWdtZW50LmlzQWxwaGFudW1lcmljKHRleHQpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignU3RyaW5nIGNvbnRhaW5zIHVuZW5jb2RhYmxlIGNoYXJhY3RlcnMgaW4gYWxwaGFudW1lcmljIG1vZGUnKTtcbiAgICAgIGxldCBiYjogYml0W10gPSBbXTtcbiAgICAgIGxldCBpOiBpbnQ7XG4gICAgICBmb3IgKGkgPSAwOyBpICsgMiA8PSB0ZXh0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIC8vIFByb2Nlc3MgZ3JvdXBzIG9mIDJcbiAgICAgICAgbGV0IHRlbXA6IGludCA9IFFyU2VnbWVudC5BTFBIQU5VTUVSSUNfQ0hBUlNFVC5pbmRleE9mKHRleHQuY2hhckF0KGkpKSAqIDQ1O1xuICAgICAgICB0ZW1wICs9IFFyU2VnbWVudC5BTFBIQU5VTUVSSUNfQ0hBUlNFVC5pbmRleE9mKHRleHQuY2hhckF0KGkgKyAxKSk7XG4gICAgICAgIGFwcGVuZEJpdHModGVtcCwgMTEsIGJiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgdGV4dC5sZW5ndGgpXG4gICAgICAgIC8vIDEgY2hhcmFjdGVyIHJlbWFpbmluZ1xuICAgICAgICBhcHBlbmRCaXRzKFFyU2VnbWVudC5BTFBIQU5VTUVSSUNfQ0hBUlNFVC5pbmRleE9mKHRleHQuY2hhckF0KGkpKSwgNiwgYmIpO1xuICAgICAgcmV0dXJuIG5ldyBRclNlZ21lbnQoUXJTZWdtZW50Lk1vZGUuQUxQSEFOVU1FUklDLCB0ZXh0Lmxlbmd0aCwgYmIpO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBuZXcgbXV0YWJsZSBsaXN0IG9mIHplcm8gb3IgbW9yZSBzZWdtZW50cyB0byByZXByZXNlbnQgdGhlIGdpdmVuIFVuaWNvZGUgdGV4dCBzdHJpbmcuXG4gICAgLy8gVGhlIHJlc3VsdCBtYXkgdXNlIHZhcmlvdXMgc2VnbWVudCBtb2RlcyBhbmQgc3dpdGNoIG1vZGVzIHRvIG9wdGltaXplIHRoZSBsZW5ndGggb2YgdGhlIGJpdCBzdHJlYW0uXG4gICAgcHVibGljIHN0YXRpYyBtYWtlU2VnbWVudHModGV4dDogc3RyaW5nKTogUXJTZWdtZW50W10ge1xuICAgICAgLy8gU2VsZWN0IHRoZSBtb3N0IGVmZmljaWVudCBzZWdtZW50IGVuY29kaW5nIGF1dG9tYXRpY2FsbHlcbiAgICAgIGlmICh0ZXh0ID09ICcnKSByZXR1cm4gW107XG4gICAgICBlbHNlIGlmIChRclNlZ21lbnQuaXNOdW1lcmljKHRleHQpKSByZXR1cm4gW1FyU2VnbWVudC5tYWtlTnVtZXJpYyh0ZXh0KV07XG4gICAgICBlbHNlIGlmIChRclNlZ21lbnQuaXNBbHBoYW51bWVyaWModGV4dCkpIHJldHVybiBbUXJTZWdtZW50Lm1ha2VBbHBoYW51bWVyaWModGV4dCldO1xuICAgICAgZWxzZSByZXR1cm4gW1FyU2VnbWVudC5tYWtlQnl0ZXMoUXJTZWdtZW50LnRvVXRmOEJ5dGVBcnJheSh0ZXh0KSldO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBzZWdtZW50IHJlcHJlc2VudGluZyBhbiBFeHRlbmRlZCBDaGFubmVsIEludGVycHJldGF0aW9uXG4gICAgLy8gKEVDSSkgZGVzaWduYXRvciB3aXRoIHRoZSBnaXZlbiBhc3NpZ25tZW50IHZhbHVlLlxuICAgIHB1YmxpYyBzdGF0aWMgbWFrZUVjaShhc3NpZ25WYWw6IGludCk6IFFyU2VnbWVudCB7XG4gICAgICBsZXQgYmI6IGJpdFtdID0gW107XG4gICAgICBpZiAoYXNzaWduVmFsIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0VDSSBhc3NpZ25tZW50IHZhbHVlIG91dCBvZiByYW5nZScpO1xuICAgICAgZWxzZSBpZiAoYXNzaWduVmFsIDwgMSA8PCA3KSBhcHBlbmRCaXRzKGFzc2lnblZhbCwgOCwgYmIpO1xuICAgICAgZWxzZSBpZiAoYXNzaWduVmFsIDwgMSA8PCAxNCkge1xuICAgICAgICBhcHBlbmRCaXRzKDBiMTAsIDIsIGJiKTtcbiAgICAgICAgYXBwZW5kQml0cyhhc3NpZ25WYWwsIDE0LCBiYik7XG4gICAgICB9IGVsc2UgaWYgKGFzc2lnblZhbCA8IDEwMDAwMDApIHtcbiAgICAgICAgYXBwZW5kQml0cygwYjExMCwgMywgYmIpO1xuICAgICAgICBhcHBlbmRCaXRzKGFzc2lnblZhbCwgMjEsIGJiKTtcbiAgICAgIH0gZWxzZSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRUNJIGFzc2lnbm1lbnQgdmFsdWUgb3V0IG9mIHJhbmdlJyk7XG4gICAgICByZXR1cm4gbmV3IFFyU2VnbWVudChRclNlZ21lbnQuTW9kZS5FQ0ksIDAsIGJiKTtcbiAgICB9XG5cbiAgICAvLyBUZXN0cyB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgY2FuIGJlIGVuY29kZWQgYXMgYSBzZWdtZW50IGluIG51bWVyaWMgbW9kZS5cbiAgICAvLyBBIHN0cmluZyBpcyBlbmNvZGFibGUgaWZmIGVhY2ggY2hhcmFjdGVyIGlzIGluIHRoZSByYW5nZSAwIHRvIDkuXG4gICAgcHVibGljIHN0YXRpYyBpc051bWVyaWModGV4dDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gUXJTZWdtZW50Lk5VTUVSSUNfUkVHRVgudGVzdCh0ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBUZXN0cyB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgY2FuIGJlIGVuY29kZWQgYXMgYSBzZWdtZW50IGluIGFscGhhbnVtZXJpYyBtb2RlLlxuICAgIC8vIEEgc3RyaW5nIGlzIGVuY29kYWJsZSBpZmYgZWFjaCBjaGFyYWN0ZXIgaXMgaW4gdGhlIGZvbGxvd2luZyBzZXQ6IDAgdG8gOSwgQSB0byBaXG4gICAgLy8gKHVwcGVyY2FzZSBvbmx5KSwgc3BhY2UsIGRvbGxhciwgcGVyY2VudCwgYXN0ZXJpc2ssIHBsdXMsIGh5cGhlbiwgcGVyaW9kLCBzbGFzaCwgY29sb24uXG4gICAgcHVibGljIHN0YXRpYyBpc0FscGhhbnVtZXJpYyh0ZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBRclNlZ21lbnQuQUxQSEFOVU1FUklDX1JFR0VYLnRlc3QodGV4dCk7XG4gICAgfVxuXG4gICAgLyotLSBDb25zdHJ1Y3RvciAobG93IGxldmVsKSBhbmQgZmllbGRzIC0tKi9cblxuICAgIC8vIENyZWF0ZXMgYSBuZXcgUVIgQ29kZSBzZWdtZW50IHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMgYW5kIGRhdGEuXG4gICAgLy8gVGhlIGNoYXJhY3RlciBjb3VudCAobnVtQ2hhcnMpIG11c3QgYWdyZWUgd2l0aCB0aGUgbW9kZSBhbmQgdGhlIGJpdCBidWZmZXIgbGVuZ3RoLFxuICAgIC8vIGJ1dCB0aGUgY29uc3RyYWludCBpc24ndCBjaGVja2VkLiBUaGUgZ2l2ZW4gYml0IGJ1ZmZlciBpcyBjbG9uZWQgYW5kIHN0b3JlZC5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgICAvLyBUaGUgbW9kZSBpbmRpY2F0b3Igb2YgdGhpcyBzZWdtZW50LlxuICAgICAgcHVibGljIHJlYWRvbmx5IG1vZGU6IFFyU2VnbWVudC5Nb2RlLFxuXG4gICAgICAvLyBUaGUgbGVuZ3RoIG9mIHRoaXMgc2VnbWVudCdzIHVuZW5jb2RlZCBkYXRhLiBNZWFzdXJlZCBpbiBjaGFyYWN0ZXJzIGZvclxuICAgICAgLy8gbnVtZXJpYy9hbHBoYW51bWVyaWMva2FuamkgbW9kZSwgYnl0ZXMgZm9yIGJ5dGUgbW9kZSwgYW5kIDAgZm9yIEVDSSBtb2RlLlxuICAgICAgLy8gQWx3YXlzIHplcm8gb3IgcG9zaXRpdmUuIE5vdCB0aGUgc2FtZSBhcyB0aGUgZGF0YSdzIGJpdCBsZW5ndGguXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgbnVtQ2hhcnM6IGludCxcblxuICAgICAgLy8gVGhlIGRhdGEgYml0cyBvZiB0aGlzIHNlZ21lbnQuIEFjY2Vzc2VkIHRocm91Z2ggZ2V0RGF0YSgpLlxuICAgICAgcHJpdmF0ZSByZWFkb25seSBiaXREYXRhOiBiaXRbXVxuICAgICkge1xuICAgICAgaWYgKG51bUNoYXJzIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIHRoaXMuYml0RGF0YSA9IGJpdERhdGEuc2xpY2UoKTsgLy8gTWFrZSBkZWZlbnNpdmUgY29weVxuICAgIH1cblxuICAgIC8qLS0gTWV0aG9kcyAtLSovXG5cbiAgICAvLyBSZXR1cm5zIGEgbmV3IGNvcHkgb2YgdGhlIGRhdGEgYml0cyBvZiB0aGlzIHNlZ21lbnQuXG4gICAgcHVibGljIGdldERhdGEoKTogYml0W10ge1xuICAgICAgcmV0dXJuIHRoaXMuYml0RGF0YS5zbGljZSgpOyAvLyBNYWtlIGRlZmVuc2l2ZSBjb3B5XG4gICAgfVxuXG4gICAgLy8gKFBhY2thZ2UtcHJpdmF0ZSkgQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIGVuY29kZSB0aGUgZ2l2ZW4gc2VnbWVudHMgYXRcbiAgICAvLyB0aGUgZ2l2ZW4gdmVyc2lvbi4gVGhlIHJlc3VsdCBpcyBpbmZpbml0eSBpZiBhIHNlZ21lbnQgaGFzIHRvbyBtYW55IGNoYXJhY3RlcnMgdG8gZml0IGl0cyBsZW5ndGggZmllbGQuXG4gICAgcHVibGljIHN0YXRpYyBnZXRUb3RhbEJpdHMoc2VnczogUmVhZG9ubHk8UXJTZWdtZW50W10+LCB2ZXJzaW9uOiBpbnQpOiBudW1iZXIge1xuICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGNvbnN0IGNjYml0czogaW50ID0gc2VnLm1vZGUubnVtQ2hhckNvdW50Qml0cyh2ZXJzaW9uKTtcbiAgICAgICAgaWYgKHNlZy5udW1DaGFycyA+PSAxIDw8IGNjYml0cykgcmV0dXJuIEluZmluaXR5OyAvLyBUaGUgc2VnbWVudCdzIGxlbmd0aCBkb2Vzbid0IGZpdCB0aGUgZmllbGQncyBiaXQgd2lkdGhcbiAgICAgICAgcmVzdWx0ICs9IDQgKyBjY2JpdHMgKyBzZWcuYml0RGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBuZXcgYXJyYXkgb2YgYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBzdHJpbmcgZW5jb2RlZCBpbiBVVEYtOC5cbiAgICBwcml2YXRlIHN0YXRpYyB0b1V0ZjhCeXRlQXJyYXkoc3RyOiBzdHJpbmcpOiBieXRlW10ge1xuICAgICAgc3RyID0gZW5jb2RlVVJJKHN0cik7XG4gICAgICBsZXQgcmVzdWx0OiBieXRlW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KGkpICE9ICclJykgcmVzdWx0LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzdHIuc3Vic3RyaW5nKGkgKyAxLCBpICsgMyksIDE2KSk7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0gQ29uc3RhbnRzIC0tKi9cblxuICAgIC8vIERlc2NyaWJlcyBwcmVjaXNlbHkgYWxsIHN0cmluZ3MgdGhhdCBhcmUgZW5jb2RhYmxlIGluIG51bWVyaWMgbW9kZS5cbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBOVU1FUklDX1JFR0VYOiBSZWdFeHAgPSAvXlswLTldKiQvO1xuXG4gICAgLy8gRGVzY3JpYmVzIHByZWNpc2VseSBhbGwgc3RyaW5ncyB0aGF0IGFyZSBlbmNvZGFibGUgaW4gYWxwaGFudW1lcmljIG1vZGUuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQUxQSEFOVU1FUklDX1JFR0VYOiBSZWdFeHAgPSAvXltBLVowLTkgJCUqKy5cXC86LV0qJC87XG5cbiAgICAvLyBUaGUgc2V0IG9mIGFsbCBsZWdhbCBjaGFyYWN0ZXJzIGluIGFscGhhbnVtZXJpYyBtb2RlLFxuICAgIC8vIHdoZXJlIGVhY2ggY2hhcmFjdGVyIHZhbHVlIG1hcHMgdG8gdGhlIGluZGV4IGluIHRoZSBzdHJpbmcuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQUxQSEFOVU1FUklDX0NIQVJTRVQ6IHN0cmluZyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogJCUqKy0uLzonO1xuICB9XG59XG5cbi8qLS0tLSBQdWJsaWMgaGVscGVyIGVudW1lcmF0aW9uIC0tLS0qL1xuXG5uYW1lc3BhY2UgcXJjb2RlZ2VuLlFyQ29kZSB7XG4gIHR5cGUgaW50ID0gbnVtYmVyO1xuXG4gIC8qXG4gICAqIFRoZSBlcnJvciBjb3JyZWN0aW9uIGxldmVsIGluIGEgUVIgQ29kZSBzeW1ib2wuIEltbXV0YWJsZS5cbiAgICovXG4gIGV4cG9ydCBjbGFzcyBFY2Mge1xuICAgIC8qLS0gQ29uc3RhbnRzIC0tKi9cblxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTE9XID0gbmV3IEVjYygwLCAxKTsgLy8gVGhlIFFSIENvZGUgY2FuIHRvbGVyYXRlIGFib3V0ICA3JSBlcnJvbmVvdXMgY29kZXdvcmRzXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBNRURJVU0gPSBuZXcgRWNjKDEsIDApOyAvLyBUaGUgUVIgQ29kZSBjYW4gdG9sZXJhdGUgYWJvdXQgMTUlIGVycm9uZW91cyBjb2Rld29yZHNcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFFVQVJUSUxFID0gbmV3IEVjYygyLCAzKTsgLy8gVGhlIFFSIENvZGUgY2FuIHRvbGVyYXRlIGFib3V0IDI1JSBlcnJvbmVvdXMgY29kZXdvcmRzXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBISUdIID0gbmV3IEVjYygzLCAyKTsgLy8gVGhlIFFSIENvZGUgY2FuIHRvbGVyYXRlIGFib3V0IDMwJSBlcnJvbmVvdXMgY29kZXdvcmRzXG5cbiAgICAvKi0tIENvbnN0cnVjdG9yIGFuZCBmaWVsZHMgLS0qL1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICAgIC8vIEluIHRoZSByYW5nZSAwIHRvIDMgKHVuc2lnbmVkIDItYml0IGludGVnZXIpLlxuICAgICAgcHVibGljIHJlYWRvbmx5IG9yZGluYWw6IGludCxcbiAgICAgIC8vIChQYWNrYWdlLXByaXZhdGUpIEluIHRoZSByYW5nZSAwIHRvIDMgKHVuc2lnbmVkIDItYml0IGludGVnZXIpLlxuICAgICAgcHVibGljIHJlYWRvbmx5IGZvcm1hdEJpdHM6IGludFxuICAgICkge31cbiAgfVxufVxuXG4vKi0tLS0gUHVibGljIGhlbHBlciBlbnVtZXJhdGlvbiAtLS0tKi9cblxubmFtZXNwYWNlIHFyY29kZWdlbi5RclNlZ21lbnQge1xuICB0eXBlIGludCA9IG51bWJlcjtcblxuICAvKlxuICAgKiBEZXNjcmliZXMgaG93IGEgc2VnbWVudCdzIGRhdGEgYml0cyBhcmUgaW50ZXJwcmV0ZWQuIEltbXV0YWJsZS5cbiAgICovXG4gIGV4cG9ydCBjbGFzcyBNb2RlIHtcbiAgICAvKi0tIENvbnN0YW50cyAtLSovXG5cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE5VTUVSSUMgPSBuZXcgTW9kZSgweDEsIFsxMCwgMTIsIDE0XSk7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBBTFBIQU5VTUVSSUMgPSBuZXcgTW9kZSgweDIsIFs5LCAxMSwgMTNdKTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEJZVEUgPSBuZXcgTW9kZSgweDQsIFs4LCAxNiwgMTZdKTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEtBTkpJID0gbmV3IE1vZGUoMHg4LCBbOCwgMTAsIDEyXSk7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBFQ0kgPSBuZXcgTW9kZSgweDcsIFswLCAwLCAwXSk7XG5cbiAgICAvKi0tIENvbnN0cnVjdG9yIGFuZCBmaWVsZHMgLS0qL1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICAgIC8vIFRoZSBtb2RlIGluZGljYXRvciBiaXRzLCB3aGljaCBpcyBhIHVpbnQ0IHZhbHVlIChyYW5nZSAwIHRvIDE1KS5cbiAgICAgIHB1YmxpYyByZWFkb25seSBtb2RlQml0czogaW50LFxuICAgICAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlciBjb3VudCBiaXRzIGZvciB0aHJlZSBkaWZmZXJlbnQgdmVyc2lvbiByYW5nZXMuXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IG51bUJpdHNDaGFyQ291bnQ6IFtpbnQsIGludCwgaW50XVxuICAgICkge31cblxuICAgIC8qLS0gTWV0aG9kIC0tKi9cblxuICAgIC8vIChQYWNrYWdlLXByaXZhdGUpIFJldHVybnMgdGhlIGJpdCB3aWR0aCBvZiB0aGUgY2hhcmFjdGVyIGNvdW50IGZpZWxkIGZvciBhIHNlZ21lbnQgaW5cbiAgICAvLyB0aGlzIG1vZGUgaW4gYSBRUiBDb2RlIGF0IHRoZSBnaXZlbiB2ZXJzaW9uIG51bWJlci4gVGhlIHJlc3VsdCBpcyBpbiB0aGUgcmFuZ2UgWzAsIDE2XS5cbiAgICBwdWJsaWMgbnVtQ2hhckNvdW50Qml0cyh2ZXI6IGludCk6IGludCB7XG4gICAgICByZXR1cm4gdGhpcy5udW1CaXRzQ2hhckNvdW50W01hdGguZmxvb3IoKHZlciArIDcpIC8gMTcpXTtcbiAgICB9XG4gIH1cbn1cblxuLy8gTW9kaWZpY2F0aW9uIHRvIGV4cG9ydCBmb3IgYWN0dWFsIHVzZVxuZXhwb3J0IGRlZmF1bHQgcXJjb2RlZ2VuO1xuIl19