/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { NgForOf } from '@angular/common';
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import * as i0 from "@angular/core";
export class NzTreeIndentComponent {
    constructor() {
        this.nzTreeLevel = 0;
        this.nzIsStart = [];
        this.nzIsEnd = [];
        this.nzSelectMode = false;
        this.listOfUnit = [];
    }
    ngOnChanges(changes) {
        const { nzTreeLevel } = changes;
        if (nzTreeLevel) {
            this.listOfUnit = [...new Array(nzTreeLevel.currentValue || 0)];
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.7", ngImport: i0, type: NzTreeIndentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.7", type: NzTreeIndentComponent, isStandalone: true, selector: "nz-tree-indent", inputs: { nzTreeLevel: "nzTreeLevel", nzIsStart: "nzIsStart", nzIsEnd: "nzIsEnd", nzSelectMode: "nzSelectMode" }, host: { properties: { "attr.aria-hidden": "true", "class.ant-tree-indent": "!nzSelectMode", "class.ant-select-tree-indent": "nzSelectMode" } }, exportAs: ["nzTreeIndent"], usesOnChanges: true, ngImport: i0, template: `
    <span
      [class.ant-tree-indent-unit]="!nzSelectMode"
      [class.ant-select-tree-indent-unit]="nzSelectMode"
      [class.ant-select-tree-indent-unit-start]="nzSelectMode && nzIsStart[i]"
      [class.ant-tree-indent-unit-start]="!nzSelectMode && nzIsStart[i]"
      [class.ant-select-tree-indent-unit-end]="nzSelectMode && nzIsEnd[i]"
      [class.ant-tree-indent-unit-end]="!nzSelectMode && nzIsEnd[i]"
      *ngFor="let _ of listOfUnit; let i = index"
    ></span>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.7", ngImport: i0, type: NzTreeIndentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-indent',
                    exportAs: 'nzTreeIndent',
                    template: `
    <span
      [class.ant-tree-indent-unit]="!nzSelectMode"
      [class.ant-select-tree-indent-unit]="nzSelectMode"
      [class.ant-select-tree-indent-unit-start]="nzSelectMode && nzIsStart[i]"
      [class.ant-tree-indent-unit-start]="!nzSelectMode && nzIsStart[i]"
      [class.ant-select-tree-indent-unit-end]="nzSelectMode && nzIsEnd[i]"
      [class.ant-tree-indent-unit-end]="!nzSelectMode && nzIsEnd[i]"
      *ngFor="let _ of listOfUnit; let i = index"
    ></span>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    host: {
                        '[attr.aria-hidden]': 'true',
                        '[class.ant-tree-indent]': '!nzSelectMode',
                        '[class.ant-select-tree-indent]': 'nzSelectMode'
                    },
                    imports: [NgForOf],
                    standalone: true
                }]
        }], propDecorators: { nzTreeLevel: [{
                type: Input
            }], nzIsStart: [{
                type: Input
            }], nzIsEnd: [{
                type: Input
            }], nzSelectMode: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1pbmRlbnQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vY29tcG9uZW50cy90cmVlL3RyZWUtaW5kZW50LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFFSCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDMUMsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQTRCLE1BQU0sZUFBZSxDQUFDOztBQTBCcEcsTUFBTSxPQUFPLHFCQUFxQjtJQXhCbEM7UUF5QlcsZ0JBQVcsR0FBRyxDQUFDLENBQUM7UUFDaEIsY0FBUyxHQUFjLEVBQUUsQ0FBQztRQUMxQixZQUFPLEdBQWMsRUFBRSxDQUFDO1FBQ3hCLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBRTlCLGVBQVUsR0FBYSxFQUFFLENBQUM7S0FRM0I7SUFOQyxXQUFXLENBQUMsT0FBc0I7UUFDaEMsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUNoQyxJQUFJLFdBQVcsRUFBRTtZQUNmLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxHQUFHLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqRTtJQUNILENBQUM7OEdBYlUscUJBQXFCO2tHQUFyQixxQkFBcUIsNlhBckJ0Qjs7Ozs7Ozs7OztHQVVULDREQVFTLE9BQU87OzJGQUdOLHFCQUFxQjtrQkF4QmpDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGdCQUFnQjtvQkFDMUIsUUFBUSxFQUFFLGNBQWM7b0JBQ3hCLFFBQVEsRUFBRTs7Ozs7Ozs7OztHQVVUO29CQUNELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxtQkFBbUIsRUFBRSxLQUFLO29CQUMxQixJQUFJLEVBQUU7d0JBQ0osb0JBQW9CLEVBQUUsTUFBTTt3QkFDNUIseUJBQXlCLEVBQUUsZUFBZTt3QkFDMUMsZ0NBQWdDLEVBQUUsY0FBYztxQkFDakQ7b0JBQ0QsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDO29CQUNsQixVQUFVLEVBQUUsSUFBSTtpQkFDakI7OEJBRVUsV0FBVztzQkFBbkIsS0FBSztnQkFDRyxTQUFTO3NCQUFqQixLQUFLO2dCQUNHLE9BQU87c0JBQWYsS0FBSztnQkFDRyxZQUFZO3NCQUFwQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHsgTmdGb3JPZiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBJbnB1dCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ256LXRyZWUtaW5kZW50JyxcbiAgZXhwb3J0QXM6ICduelRyZWVJbmRlbnQnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzcGFuXG4gICAgICBbY2xhc3MuYW50LXRyZWUtaW5kZW50LXVuaXRdPVwiIW56U2VsZWN0TW9kZVwiXG4gICAgICBbY2xhc3MuYW50LXNlbGVjdC10cmVlLWluZGVudC11bml0XT1cIm56U2VsZWN0TW9kZVwiXG4gICAgICBbY2xhc3MuYW50LXNlbGVjdC10cmVlLWluZGVudC11bml0LXN0YXJ0XT1cIm56U2VsZWN0TW9kZSAmJiBueklzU3RhcnRbaV1cIlxuICAgICAgW2NsYXNzLmFudC10cmVlLWluZGVudC11bml0LXN0YXJ0XT1cIiFuelNlbGVjdE1vZGUgJiYgbnpJc1N0YXJ0W2ldXCJcbiAgICAgIFtjbGFzcy5hbnQtc2VsZWN0LXRyZWUtaW5kZW50LXVuaXQtZW5kXT1cIm56U2VsZWN0TW9kZSAmJiBueklzRW5kW2ldXCJcbiAgICAgIFtjbGFzcy5hbnQtdHJlZS1pbmRlbnQtdW5pdC1lbmRdPVwiIW56U2VsZWN0TW9kZSAmJiBueklzRW5kW2ldXCJcbiAgICAgICpuZ0Zvcj1cImxldCBfIG9mIGxpc3RPZlVuaXQ7IGxldCBpID0gaW5kZXhcIlxuICAgID48L3NwYW4+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgaG9zdDoge1xuICAgICdbYXR0ci5hcmlhLWhpZGRlbl0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5hbnQtdHJlZS1pbmRlbnRdJzogJyFuelNlbGVjdE1vZGUnLFxuICAgICdbY2xhc3MuYW50LXNlbGVjdC10cmVlLWluZGVudF0nOiAnbnpTZWxlY3RNb2RlJ1xuICB9LFxuICBpbXBvcnRzOiBbTmdGb3JPZl0sXG4gIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgTnpUcmVlSW5kZW50Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgbnpUcmVlTGV2ZWwgPSAwO1xuICBASW5wdXQoKSBueklzU3RhcnQ6IGJvb2xlYW5bXSA9IFtdO1xuICBASW5wdXQoKSBueklzRW5kOiBib29sZWFuW10gPSBbXTtcbiAgQElucHV0KCkgbnpTZWxlY3RNb2RlID0gZmFsc2U7XG5cbiAgbGlzdE9mVW5pdDogbnVtYmVyW10gPSBbXTtcblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgY29uc3QgeyBuelRyZWVMZXZlbCB9ID0gY2hhbmdlcztcbiAgICBpZiAobnpUcmVlTGV2ZWwpIHtcbiAgICAgIHRoaXMubGlzdE9mVW5pdCA9IFsuLi5uZXcgQXJyYXkobnpUcmVlTGV2ZWwuY3VycmVudFZhbHVlIHx8IDApXTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==