import { __decorate } from "tslib";
import { NgClass, NgForOf, NgIf } from '@angular/common';
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, forwardRef, Input, Optional, Output, ViewChildren, ViewEncapsulation } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { thumbMotion } from 'ng-zorro-antd/core/animation';
import { WithConfig } from 'ng-zorro-antd/core/config';
import { NzOutletModule } from 'ng-zorro-antd/core/outlet';
import { InputBoolean } from 'ng-zorro-antd/core/util';
import { NzIconModule } from 'ng-zorro-antd/icon';
import { normalizeOptions } from './types';
import * as i0 from "@angular/core";
import * as i1 from "ng-zorro-antd/core/config";
import * as i2 from "@angular/cdk/bidi";
import * as i3 from "ng-zorro-antd/icon";
import * as i4 from "ng-zorro-antd/core/outlet";
const NZ_CONFIG_MODULE_NAME = 'segmented';
export class NzSegmentedComponent {
    constructor(nzConfigService, cdr, directionality) {
        this.nzConfigService = nzConfigService;
        this.cdr = cdr;
        this.directionality = directionality;
        this._nzModuleName = NZ_CONFIG_MODULE_NAME;
        this.nzBlock = false;
        this.nzDisabled = false;
        this.nzOptions = [];
        this.nzSize = 'default';
        this.nzLabelTemplate = null;
        this.nzValueChange = new EventEmitter();
        this.dir = 'ltr';
        this.selectedIndex = 0;
        this.transitionedToIndex = -1;
        this.animationState = null;
        this.normalizedOptions = [];
        this.destroy$ = new Subject();
        this.onChange = () => { };
        this.onTouched = () => { };
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe(direction => {
            this.dir = direction;
            this.cdr.detectChanges();
        });
    }
    ngOnChanges(changes) {
        const { nzOptions } = changes;
        if (nzOptions) {
            this.normalizedOptions = normalizeOptions(nzOptions.currentValue);
        }
    }
    handleOptionClick(index) {
        if (this.nzDisabled) {
            return;
        }
        this.changeSelectedIndex(index);
        this.onChange(index);
        this.nzValueChange.emit(index);
    }
    handleThumbAnimationDone(e) {
        if (e.fromState === 'from') {
            this.selectedIndex = this.transitionedToIndex;
            this.transitionedToIndex = -1;
            this.animationState = null;
            this.cdr.detectChanges();
        }
    }
    writeValue(value) {
        if (typeof value === 'number' && value > -1) {
            this.changeSelectedIndex(value);
            this.cdr.markForCheck();
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    changeSelectedIndex(index) {
        if (!this.listOfOptions || this.selectedIndex === -1 || this.selectedIndex === index) {
            return;
        }
        this.animationState = {
            value: 'from',
            params: getThumbAnimationProps(this.listOfOptions.get(this.selectedIndex).nativeElement)
        };
        this.selectedIndex = -1;
        this.cdr.detectChanges();
        this.animationState = {
            value: 'to',
            params: getThumbAnimationProps(this.listOfOptions.get(index).nativeElement)
        };
        this.transitionedToIndex = index;
        this.cdr.detectChanges();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.7", ngImport: i0, type: NzSegmentedComponent, deps: [{ token: i1.NzConfigService }, { token: i0.ChangeDetectorRef }, { token: i2.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.7", type: NzSegmentedComponent, isStandalone: true, selector: "nz-segmented", inputs: { nzBlock: "nzBlock", nzDisabled: "nzDisabled", nzOptions: "nzOptions", nzSize: "nzSize", nzLabelTemplate: "nzLabelTemplate" }, outputs: { nzValueChange: "nzValueChange" }, host: { properties: { "class.ant-segmented-disabled": "!!nzDisabled", "class.ant-segmented-rtl": "dir === 'rtl'", "class.ant-segmented-lg": "nzSize === 'large'", "class.ant-segmented-sm": "nzSize === 'small'", "class.ant-segmented-block": "!!nzBlock" }, classAttribute: "ant-segmented" }, providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NzSegmentedComponent), multi: true }], viewQueries: [{ propertyName: "listOfOptions", predicate: ["itemLabels"], descendants: true, read: ElementRef }], exportAs: ["nzSegmented"], usesOnChanges: true, ngImport: i0, template: `
    <!-- thumb motion div -->
    <div class="ant-segmented-group">
      <div
        *ngIf="animationState"
        [ngClass]="{ 'ant-segmented-thumb': true, 'ant-segmented-thumb-motion': true }"
        [@thumbMotion]="animationState"
        (@thumbMotion.done)="handleThumbAnimationDone($event)"
      ></div>
      <label
        #itemLabels
        *ngFor="let item of normalizedOptions; let i = index"
        [ngClass]="{
          'ant-segmented-item': true,
          'ant-segmented-item-selected': i === selectedIndex,
          'ant-segmented-item-disabled': !!nzDisabled || item.disabled
        }"
      >
        <input class="ant-segmented-item-input" type="radio" [checked]="i === selectedIndex" />
        <div class="ant-segmented-item-label" (click)="!item.disabled && handleOptionClick(i)">
          <ng-container *ngIf="item.icon; else else_template">
            <span class="ant-segmented-item-icon"><span nz-icon [nzType]="item.icon"></span></span>
            <span>
              <ng-container
                *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
              >
                {{ item.label }}
              </ng-container>
            </span>
          </ng-container>
          <ng-template #else_template>
            <ng-container
              *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
            >
              {{ item.label }}
            </ng-container>
          </ng-template>
        </div>
      </label>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "ngmodule", type: NzIconModule }, { kind: "directive", type: i3.NzIconDirective, selector: "[nz-icon]", inputs: ["nzSpin", "nzRotate", "nzType", "nzTheme", "nzTwotoneColor", "nzIconfont"], exportAs: ["nzIcon"] }, { kind: "ngmodule", type: NzOutletModule }, { kind: "directive", type: i4.NzStringTemplateOutletDirective, selector: "[nzStringTemplateOutlet]", inputs: ["nzStringTemplateOutletContext", "nzStringTemplateOutlet"], exportAs: ["nzStringTemplateOutlet"] }], animations: [thumbMotion], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
__decorate([
    InputBoolean()
], NzSegmentedComponent.prototype, "nzBlock", void 0);
__decorate([
    InputBoolean()
], NzSegmentedComponent.prototype, "nzDisabled", void 0);
__decorate([
    WithConfig()
], NzSegmentedComponent.prototype, "nzSize", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.7", ngImport: i0, type: NzSegmentedComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    selector: 'nz-segmented',
                    exportAs: 'nzSegmented',
                    template: `
    <!-- thumb motion div -->
    <div class="ant-segmented-group">
      <div
        *ngIf="animationState"
        [ngClass]="{ 'ant-segmented-thumb': true, 'ant-segmented-thumb-motion': true }"
        [@thumbMotion]="animationState"
        (@thumbMotion.done)="handleThumbAnimationDone($event)"
      ></div>
      <label
        #itemLabels
        *ngFor="let item of normalizedOptions; let i = index"
        [ngClass]="{
          'ant-segmented-item': true,
          'ant-segmented-item-selected': i === selectedIndex,
          'ant-segmented-item-disabled': !!nzDisabled || item.disabled
        }"
      >
        <input class="ant-segmented-item-input" type="radio" [checked]="i === selectedIndex" />
        <div class="ant-segmented-item-label" (click)="!item.disabled && handleOptionClick(i)">
          <ng-container *ngIf="item.icon; else else_template">
            <span class="ant-segmented-item-icon"><span nz-icon [nzType]="item.icon"></span></span>
            <span>
              <ng-container
                *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
              >
                {{ item.label }}
              </ng-container>
            </span>
          </ng-container>
          <ng-template #else_template>
            <ng-container
              *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
            >
              {{ item.label }}
            </ng-container>
          </ng-template>
        </div>
      </label>
    </div>
  `,
                    host: {
                        class: 'ant-segmented',
                        '[class.ant-segmented-disabled]': '!!nzDisabled',
                        '[class.ant-segmented-rtl]': `dir === 'rtl'`,
                        '[class.ant-segmented-lg]': `nzSize === 'large'`,
                        '[class.ant-segmented-sm]': `nzSize === 'small'`,
                        '[class.ant-segmented-block]': `!!nzBlock`
                    },
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NzSegmentedComponent), multi: true }],
                    animations: [thumbMotion],
                    imports: [NgIf, NgClass, NgForOf, NzIconModule, NzOutletModule],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.NzConfigService }, { type: i0.ChangeDetectorRef }, { type: i2.Directionality, decorators: [{
                    type: Optional
                }] }], propDecorators: { listOfOptions: [{
                type: ViewChildren,
                args: ['itemLabels', { read: ElementRef }]
            }], nzBlock: [{
                type: Input
            }], nzDisabled: [{
                type: Input
            }], nzOptions: [{
                type: Input
            }], nzSize: [{
                type: Input
            }], nzLabelTemplate: [{
                type: Input
            }], nzValueChange: [{
                type: Output
            }] } });
function getThumbAnimationProps(element) {
    return {
        transform: element.offsetLeft,
        width: element.clientWidth
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VnbWVudGVkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2NvbXBvbmVudHMvc2VnbWVudGVkL3NlZ21lbnRlZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQU1BLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pELE9BQU8sRUFDTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osVUFBVSxFQUNWLEtBQUssRUFFTCxRQUFRLEVBQ1IsTUFBTSxFQUlOLFlBQVksRUFDWixpQkFBaUIsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBdUIsV0FBVyxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDaEYsT0FBTyxFQUFnQyxVQUFVLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNyRixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFFM0QsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVsRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQThELE1BQU0sU0FBUyxDQUFDOzs7Ozs7QUFFdkcsTUFBTSxxQkFBcUIsR0FBZ0IsV0FBVyxDQUFDO0FBNkR2RCxNQUFNLE9BQU8sb0JBQW9CO0lBc0MvQixZQUNrQixlQUFnQyxFQUMvQixHQUFzQixFQUNWLGNBQThCO1FBRjNDLG9CQUFlLEdBQWYsZUFBZSxDQUFpQjtRQUMvQixRQUFHLEdBQUgsR0FBRyxDQUFt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Y2VzQ29udGVudCI6WyIvKipcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ORy1aT1JSTy9uZy16b3Jyby1hbnRkL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3Rpb24sIERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgTmdDbGFzcywgTmdGb3JPZiwgTmdJZiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBmb3J3YXJkUmVmLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q2hpbGRyZW4sXG4gIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBUaHVtYkFuaW1hdGlvblByb3BzLCB0aHVtYk1vdGlvbiB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS9hbmltYXRpb24nO1xuaW1wb3J0IHsgTnpDb25maWdLZXksIE56Q29uZmlnU2VydmljZSwgV2l0aENvbmZpZyB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS9jb25maWcnO1xuaW1wb3J0IHsgTnpPdXRsZXRNb2R1bGUgfSBmcm9tICduZy16b3Jyby1hbnRkL2NvcmUvb3V0bGV0JztcbmltcG9ydCB7IEJvb2xlYW5JbnB1dCwgTnpTYWZlQW55LCBOelNpemVMRFNUeXBlLCBPbkNoYW5nZVR5cGUsIE9uVG91Y2hlZFR5cGUgfSBmcm9tICduZy16b3Jyby1hbnRkL2NvcmUvdHlwZXMnO1xuaW1wb3J0IHsgSW5wdXRCb29sZWFuIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgTnpJY29uTW9kdWxlIH0gZnJvbSAnbmctem9ycm8tYW50ZC9pY29uJztcblxuaW1wb3J0IHsgbm9ybWFsaXplT3B0aW9ucywgTnpOb3JtYWxpemVkT3B0aW9ucywgTnpTZWdtZW50ZWRPcHRpb24sIE56U2VnbWVudGVkT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBOWl9DT05GSUdfTU9EVUxFX05BTUU6IE56Q29uZmlnS2V5ID0gJ3NlZ21lbnRlZCc7XG5cbkBDb21wb25lbnQoe1xuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgc2VsZWN0b3I6ICduei1zZWdtZW50ZWQnLFxuICBleHBvcnRBczogJ256U2VnbWVudGVkJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8IS0tIHRodW1iIG1vdGlvbiBkaXYgLS0+XG4gICAgPGRpdiBjbGFzcz1cImFudC1zZWdtZW50ZWQtZ3JvdXBcIj5cbiAgICAgIDxkaXZcbiAgICAgICAgKm5nSWY9XCJhbmltYXRpb25TdGF0ZVwiXG4gICAgICAgIFtuZ0NsYXNzXT1cInsgJ2FudC1zZWdtZW50ZWQtdGh1bWInOiB0cnVlLCAnYW50LXNlZ21lbnRlZC10aHVtYi1tb3Rpb24nOiB0cnVlIH1cIlxuICAgICAgICBbQHRodW1iTW90aW9uXT1cImFuaW1hdGlvblN0YXRlXCJcbiAgICAgICAgKEB0aHVtYk1vdGlvbi5kb25lKT1cImhhbmRsZVRodW1iQW5pbWF0aW9uRG9uZSgkZXZlbnQpXCJcbiAgICAgID48L2Rpdj5cbiAgICAgIDxsYWJlbFxuICAgICAgICAjaXRlbUxhYmVsc1xuICAgICAgICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBub3JtYWxpemVkT3B0aW9uczsgbGV0IGkgPSBpbmRleFwiXG4gICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAnYW50LXNlZ21lbnRlZC1pdGVtJzogdHJ1ZSxcbiAgICAgICAgICAnYW50LXNlZ21lbnRlZC1pdGVtLXNlbGVjdGVkJzogaSA9PT0gc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAnYW50LXNlZ21lbnRlZC1pdGVtLWRpc2FibGVkJzogISFuekRpc2FibGVkIHx8IGl0ZW0uZGlzYWJsZWRcbiAgICAgICAgfVwiXG4gICAgICA+XG4gICAgICAgIDxpbnB1dCBjbGFzcz1cImFudC1zZWdtZW50ZWQtaXRlbS1pbnB1dFwiIHR5cGU9XCJyYWRpb1wiIFtjaGVja2VkXT1cImkgPT09IHNlbGVjdGVkSW5kZXhcIiAvPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYW50LXNlZ21lbnRlZC1pdGVtLWxhYmVsXCIgKGNsaWNrKT1cIiFpdGVtLmRpc2FibGVkICYmIGhhbmRsZU9wdGlvbkNsaWNrKGkpXCI+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIml0ZW0uaWNvbjsgZWxzZSBlbHNlX3RlbXBsYXRlXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFudC1zZWdtZW50ZWQtaXRlbS1pY29uXCI+PHNwYW4gbnotaWNvbiBbbnpUeXBlXT1cIml0ZW0uaWNvblwiPjwvc3Bhbj48L3NwYW4+XG4gICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICpuelN0cmluZ1RlbXBsYXRlT3V0bGV0PVwiaXRlbS51c2VUZW1wbGF0ZSAmJiBuekxhYmVsVGVtcGxhdGU7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBpdGVtLCBpbmRleDogaSB9XCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHt7IGl0ZW0ubGFiZWwgfX1cbiAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgPG5nLXRlbXBsYXRlICNlbHNlX3RlbXBsYXRlPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAqbnpTdHJpbmdUZW1wbGF0ZU91dGxldD1cIml0ZW0udXNlVGVtcGxhdGUgJiYgbnpMYWJlbFRlbXBsYXRlOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogaXRlbSwgaW5kZXg6IGkgfVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHt7IGl0ZW0ubGFiZWwgfX1cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnYW50LXNlZ21lbnRlZCcsXG4gICAgJ1tjbGFzcy5hbnQtc2VnbWVudGVkLWRpc2FibGVkXSc6ICchIW56RGlzYWJsZWQnLFxuICAgICdbY2xhc3MuYW50LXNlZ21lbnRlZC1ydGxdJzogYGRpciA9PT0gJ3J0bCdgLFxuICAgICdbY2xhc3MuYW50LXNlZ21lbnRlZC1sZ10nOiBgbnpTaXplID09PSAnbGFyZ2UnYCxcbiAgICAnW2NsYXNzLmFudC1zZWdtZW50ZWQtc21dJzogYG56U2l6ZSA9PT0gJ3NtYWxsJ2AsXG4gICAgJ1tjbGFzcy5hbnQtc2VnbWVudGVkLWJsb2NrXSc6IGAhIW56QmxvY2tgXG4gIH0sXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE56U2VnbWVudGVkQ29tcG9uZW50KSwgbXVsdGk6IHRydWUgfV0sXG4gIGFuaW1hdGlvbnM6IFt0aHVtYk1vdGlvbl0sXG4gIGltcG9ydHM6IFtOZ0lmLCBOZ0NsYXNzLCBOZ0Zvck9mLCBOekljb25Nb2R1bGUsIE56T3V0bGV0TW9kdWxlXSxcbiAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBOelNlZ21lbnRlZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbnpEaXNhYmxlZDogQm9vbGVhbklucHV0O1xuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbnpCbG9jazogQm9vbGVhbklucHV0O1xuXG4gIHJlYWRvbmx5IF9uek1vZHVsZU5hbWU6IE56Q29uZmlnS2V5ID0gTlpfQ09ORklHX01PRFVMRV9OQU1FO1xuXG4gIEBWaWV3Q2hpbGRyZW4oJ2l0ZW1MYWJlbHMnLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSkgbGlzdE9mT3B0aW9ucyE6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcblxuICBASW5wdXQoKVxuICBASW5wdXRCb29sZWFuKClcbiAgbnpCbG9jazogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBJbnB1dCgpXG4gIEBJbnB1dEJvb2xlYW4oKVxuICBuekRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQElucHV0KCkgbnpPcHRpb25zOiBOelNlZ21lbnRlZE9wdGlvbnMgPSBbXTtcblxuICBASW5wdXQoKSBAV2l0aENvbmZpZygpIG56U2l6ZTogTnpTaXplTERTVHlwZSA9ICdkZWZhdWx0JztcblxuICBASW5wdXQoKSBuekxhYmVsVGVtcGxhdGU6IFRlbXBsYXRlUmVmPHsgJGltcGxpY2l0OiBOelNlZ21lbnRlZE9wdGlvbjsgaW5kZXg6IG51bWJlciB9PiB8IG51bGwgPSBudWxsO1xuXG4gIEBPdXRwdXQoKSByZWFkb25seSBuelZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgcHVibGljIGRpcjogRGlyZWN0aW9uID0gJ2x0cic7XG5cbiAgcHVibGljIHNlbGVjdGVkSW5kZXggPSAwO1xuICBwdWJsaWMgdHJhbnNpdGlvbmVkVG9JbmRleCA9IC0xO1xuICBwdWJsaWMgYW5pbWF0aW9uU3RhdGU6IG51bGwgfCB7IHZhbHVlOiBzdHJpbmc7IHBhcmFtczogVGh1bWJBbmltYXRpb25Qcm9wcyB9ID0gbnVsbDtcblxuICBwdWJsaWMgbm9ybWFsaXplZE9wdGlvbnM6IE56Tm9ybWFsaXplZE9wdGlvbnMgPSBbXTtcblxuICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBvbkNoYW5nZTogT25DaGFuZ2VUeXBlID0gKCkgPT4ge307XG5cbiAgb25Ub3VjaGVkOiBPblRvdWNoZWRUeXBlID0gKCkgPT4ge307XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IG56Q29uZmlnU2VydmljZTogTnpDb25maWdTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIHJlYWRvbmx5IGRpcmVjdGlvbmFsaXR5OiBEaXJlY3Rpb25hbGl0eVxuICApIHtcbiAgICB0aGlzLmRpcmVjdGlvbmFsaXR5LmNoYW5nZT8ucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZShkaXJlY3Rpb24gPT4ge1xuICAgICAgdGhpcy5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgY29uc3QgeyBuek9wdGlvbnMgfSA9IGNoYW5nZXM7XG4gICAgaWYgKG56T3B0aW9ucykge1xuICAgICAgdGhpcy5ub3JtYWxpemVkT3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnMobnpPcHRpb25zLmN1cnJlbnRWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlT3B0aW9uQ2xpY2soaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLm56RGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5nZVNlbGVjdGVkSW5kZXgoaW5kZXgpO1xuXG4gICAgdGhpcy5vbkNoYW5nZShpbmRleCk7XG4gICAgdGhpcy5uelZhbHVlQ2hhbmdlLmVtaXQoaW5kZXgpO1xuICB9XG5cbiAgaGFuZGxlVGh1bWJBbmltYXRpb25Eb25lKGU6IE56U2FmZUFueSk6IHZvaWQge1xuICAgIGlmIChlLmZyb21TdGF0ZSA9PT0gJ2Zyb20nKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0aGlzLnRyYW5zaXRpb25lZFRvSW5kZXg7XG4gICAgICB0aGlzLnRyYW5zaXRpb25lZFRvSW5kZXggPSAtMTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgfVxuXG4gIHdyaXRlVmFsdWUodmFsdWU6IG51bWJlciB8IG51bGwpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xKSB7XG4gICAgICB0aGlzLmNoYW5nZVNlbGVjdGVkSW5kZXgodmFsdWUpO1xuICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogT25DaGFuZ2VUeXBlKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IE9uVG91Y2hlZFR5cGUpOiB2b2lkIHtcbiAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGFuZ2VTZWxlY3RlZEluZGV4KGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubGlzdE9mT3B0aW9ucyB8fCB0aGlzLnNlbGVjdGVkSW5kZXggPT09IC0xIHx8IHRoaXMuc2VsZWN0ZWRJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0ge1xuICAgICAgdmFsdWU6ICdmcm9tJyxcbiAgICAgIHBhcmFtczogZ2V0VGh1bWJBbmltYXRpb25Qcm9wcyh0aGlzLmxpc3RPZk9wdGlvbnMuZ2V0KHRoaXMuc2VsZWN0ZWRJbmRleCkhLm5hdGl2ZUVsZW1lbnQhKVxuICAgIH07XG4gICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IHtcbiAgICAgIHZhbHVlOiAndG8nLFxuICAgICAgcGFyYW1zOiBnZXRUaHVtYkFuaW1hdGlvblByb3BzKHRoaXMubGlzdE9mT3B0aW9ucy5nZXQoaW5kZXgpIS5uYXRpdmVFbGVtZW50ISlcbiAgICB9O1xuICAgIHRoaXMudHJhbnNpdGlvbmVkVG9JbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaHVtYkFuaW1hdGlvblByb3BzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogVGh1bWJBbmltYXRpb25Qcm9wcyB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgd2lkdGg6IGVsZW1lbnQuY2xpZW50V2lkdGhcbiAgfTtcbn1cbiJdfQ==